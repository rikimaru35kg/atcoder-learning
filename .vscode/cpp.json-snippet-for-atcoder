{
  "Snippet(Combination)": {
    "prefix": "combination",
    "body": [
      "//! Only when <= 1e6",
      "//! If not, use Combination2 class below.",
      "class Combination {",
      "    long long mx, mod;",
      "    vector<long long> facts, ifacts;",
      "public:",
      "    // argument mod must be a prime number!!",
      "    Combination(long long mx, long long mod): mx(mx), mod(mod), facts(mx+1), ifacts(mx+1) {",
      "        facts[0] = 1;",
      "        for (long long i=1; i<=mx; ++i) facts[i] = facts[i-1] * i % mod;",
      "        ifacts[mx] = modpow(facts[mx], mod-2);",
      "        for (long long i=mx-1; i>=0; --i) ifacts[i] = ifacts[i+1] * (i+1) % mod;",
      "    }",
      "    long long operator()(long long n, long long r) {",
      "        if (r < 0 || r > n || n < 0 || n > mx) return 0;",
      "        return facts[n] * ifacts[r] % mod * ifacts[n-r] % mod;",
      "    }",
      "    long long nPr(long long n, long long r) {",
      "        if (r < 0 || r > n || n < 0 || n > mx) return 0;",
      "        return facts[n] * ifacts[n-r] % mod;",
      "    }",
      "    long long get_fact(long long n) {",
      "        if (n > mx) return 0;",
      "        return facts[n];",
      "    }",
      "    long long get_factinv(long long n) {",
      "        if (n > mx) return 0;",
      "        return ifacts[n];",
      "    }",
      "    long long modpow(long long a, long long b) {",
      "        if (b == 0) return 1;",
      "        a %= mod;",
      "        long long child = modpow(a, b/2);",
      "        if (b % 2 == 0) return child * child % mod;",
      "        else return a * child % mod * child % mod;",
      "    }",
      "};"
    ]
  },
  "Snippet(Matrix)": {
    "prefix": "matrix",
    "body": [
      "//! n*n matrix",
      "//! Currently, only operator* is defined.",
      "template <typename T>",
      "class Mat {",
      "    long long n; vector<vector<T>> a; long long mod;",
      "public:",
      "    // Initialize n*n matrix",
      "    Mat (long long n, const vector<vector<T>> &mat={}, long long mod=-1)",
      "    : n(n), a(n, vector<T>(n)), mod(mod) {",
      "        // unit matrix if mat is not specified",
      "        if (mat.size() == 0) for (int i=0; i<n; ++i) a[i][i] = 1;",
      "        else {",
      "            for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "                a[i][j] = mat[i][j];",
      "                if (mod != -1) a[i][j] %= mod;",
      "            }",
      "        }",
      "    }",
      "    // Define operator*",
      "    Mat operator* (const Mat &rhs) {  // Mat * Mat",
      "        Mat ret(n);",
      "        if (mod != -1) ret = Mat(n, ret.a, mod);",
      "        ret.a.assign(n, vector<T>(n, 0));  // zero matrix",
      "        for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "            for (int k=0; k<n; ++k) {",
      "                ret.a[i][j] += a[i][k] * rhs.a[k][j];",
      "                if (mod != -1) ret.a[i][j] %= mod;",
      "            }",
      "        }",
      "        return ret;",
      "    }",
      "    vector<T> operator* (const vector<T> &rhs) {  // Mat * vector",
      "        vector<T> ret(n, 0);",
      "        for (int j=0; j<n; ++j) for (int k=0; k<n; ++k) {",
      "            ret[j] += a[j][k] * rhs[k];",
      "            if (mod != -1) ret[j] %= mod;",
      "        }",
      "        return ret;",
      "    }",
      "    // power k (A^k)",
      "    Mat pow(long long k) {",
      "        Mat ret = pow_recursive(*this, k);",
      "        return ret;",
      "    }",
      "    Mat pow_recursive(Mat b, long long k) {",
      "        Mat ret(n);",
      "        if (mod != -1) ret = Mat(n, ret.a, mod);",
      "        if (k == 0) return ret;",
      "        if (k%2 == 1) ret = b;",
      "        Mat tmp = pow_recursive(b, k/2);",
      "        return ret * tmp * tmp;",
      "    }",
      "    long long ij(long long i, long long j) {",
      "        return a[i][j];",
      "    }",
      "#ifdef __DEBUG",
      "    void print(string debugname=\"------\") {  // for debug",
      "        cerr << n << '\\n';",
      "        cerr << debugname << \":\\n\";",
      "        for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "            cerr << a[i][j] << (j==n-1? '\\n': ' ');",
      "        }",
      "        cerr << \"---------\" << '\\n';",
      "    }",
      "#else",
      "    void print(string debugname=\"------\") {}",
      "#endif",
      "};",
      ""
    ]
  },
  "Snippet(crop)": {
    "prefix": "crop",
    "body": [
      "//! Crop the rectangle that completely surrounds the specified",
      "//! character c.",
      "//! The rectangle just fits the character c area.",
      "//! (= The rectangle is selected so that the size is minimum.)",
      "vector<string> crop(vector<string> &field, char c='#') {",
      "    long long h = field.size();",
      "    long long w = field[0].size();",
      "    long long i_min = h, i_max = -1;",
      "    long long j_min = w, j_max = -1;",
      "    for(long long i=0; i<h; ++i) {",
      "        for(long long j=0; j<w; ++j) {",
      "            if (field[i][j] == c) {",
      "                i_min = min(i_min, i); i_max = max(i_max, i);",
      "                j_min = min(j_min, j); j_max = max(j_max, j);",
      "            }",
      "        }",
      "    }",
      "    vector<string> ret;",
      "    for(long long i=i_min; i<=i_max; ++i) {",
      "        ret.push_back(field[i].substr(j_min, j_max-j_min+1));",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(crop_out)": {
    "prefix": "crop_out",
    "body": [
      "//! Delete rows and columns that only include character c.",
      "vector<string> crop_out(vector<string> &field, char c='.') {",
      "    long long h = field.size();",
      "    long long w = field[0].size();",
      "    vector<bool> rows(h), cols(w); ",
      "    for(long long i=0; i<h; ++i) {",
      "        for(long long j=0; j<w; ++j) {",
      "            if (field[i][j] != c) {",
      "                rows[i] = true;",
      "                cols[j] = true;",
      "            }",
      "        }",
      "    }",
      "    vector<string> ret;",
      "    for(long long i=0; i<h; ++i) {",
      "        if (!rows[i]) continue;",
      "        ret.push_back(\"\");",
      "        for(long long j=0; j<w; ++j) {",
      "            if (cols[j]) ret.back() += field[i][j];",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(rot90)": {
    "prefix": "rot90",
    "body": [
      "//! Rotate field by +/-90deg",
      "vector<string> rot90(vector<string> &field, bool clockwise=true) {",
      "    long long h = field.size();",
      "    long long w = field[0].size();",
      "    vector<string> ret(w, string(h, ' '));",
      "    for (long long i=0; i<h; ++i) {",
      "        for (long long j=0; j<w; ++j) {",
      "            if (clockwise) ret[j][h-1-i] = field[i][j];",
      "            else ret[w-1-j][i] = field[i][j];",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(manhattan_dist)": {
    "prefix": "manhattan_dist",
    "body": [
      "//! Calculate Manhattan distance",
      "long long manhattan_dist(pair<long long,long long> p1, pair<long long,long long> p2) {",
      "    long long ret = 0;",
      "    ret += abs(p1.first - p2.first);",
      "    ret += abs(p1.second - p2.second);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(euclid_dist)": {
    "prefix": "euclid_dist",
    "body": [
      "//! Calculate Euclid distance",
      "//! input type = long long",
      "//! output type = double",
      "double euclid_dist(pair<long long,long long> p1, pair<long long,long long> p2) {",
      "    double ret = 0;",
      "    ret += (p1.first - p2.first) * (p1.first - p2.first);",
      "    ret += (p1.second - p2.second) * (p1.second - p2.second);",
      "    ret = sqrt(ret);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(euclid_distd)": {
    "prefix": "euclid_distd",
    "body": [
      "//! Calculate Euclid distance",
      "//! input type = double",
      "//! output type = double",
      "double euclid_distd(pair<double,double> p1, pair<double,double> p2) {",
      "    double ret = 0;",
      "    ret += (p1.first - p2.first) * (p1.first - p2.first);",
      "    ret += (p1.second - p2.second) * (p1.second - p2.second);",
      "    ret = sqrt(ret);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(euclid_dist2)": {
    "prefix": "euclid_dist2",
    "body": [
      "//! Calculate Euclid distance^2",
      "//! input type = long long",
      "//! output type = long long",
      "long long euclid_dist2(pair<long long,long long> p1, pair<long long,long long> p2) {",
      "    long long ret = 0;",
      "    ret += (p1.first - p2.first) * (p1.first - p2.first);",
      "    ret += (p1.second - p2.second) * (p1.second - p2.second);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(coordinate_compression)": {
    "prefix": "coordinate_compression",
    "body": [
      "class CoordinateCompression {",
      "    bool oneindexed, init = false;",
      "    vector<long long> vec;",
      "public:",
      "    CoordinateCompression(bool one=false): oneindexed(one) {}",
      "    void add (long long x) {vec.push_back(x);}",
      "    void compress () {",
      "        sort(vec.begin(), vec.end());",
      "        vec.erase(unique(vec.begin(), vec.end()), vec.end());",
      "        init = true;",
      "    }",
      "    long long operator() (long long x) {",
      "        if (!init) compress();",
      "        long long ret = lower_bound(vec.begin(), vec.end(), x) - vec.begin();",
      "        if (oneindexed) ++ret;",
      "        return ret;",
      "    }",
      "    long long operator[] (long long i) {",
      "        if (!init) compress();",
      "        if (oneindexed) --i;",
      "        if (i < 0 || i >= (long long)vec.size()) return 3e18;",
      "        return vec[i];",
      "    }",
      "    long long size () {",
      "        if (!init) compress();",
      "        return (long long)vec.size();",
      "    }",
      "#ifdef __DEBUG",
      "    void print() {",
      "        printf(\"---- cc print ----\\ni: \");",
      "        for (long long i=0; i<(long long)vec.size(); ++i) printf(\"%2lld \", i);",
      "        printf(\"\\nx: \");",
      "        for (long long i=0; i<(long long)vec.size(); ++i) printf(\"%2lld \", vec[i]);",
      "        printf(\"\\n-----------------\\n\");",
      "    }",
      "#else",
      "    void print() {}",
      "#endif",
      "};"
    ]
  },
  "Snippet(prime_factorization)": {
    "prefix": "prime_factorization",
    "body": [
      "//! eg) 360 = 2^3 * 3^2 * 5^1;",
      "//! primes = {(2,3), (3,2), (5,1)}",
      "vector<pair<long long, long long>> prime_factorization (long long n) {",
      "    vector<pair<long long, long long>> primes;",
      "    if (n <= 1) return primes;",
      "    for (long long k=2; k*k<=n; ++k) {",
      "        if (n % k != 0) continue;",
      "        primes.emplace_back(k, 0);",
      "        while(n % k == 0) {",
      "            n /= k;",
      "            primes.back().second++;",
      "        }",
      "    }",
      "    if (n != 1) primes.emplace_back(n, 1);",
      "    return primes;",
      "}"
    ]
  },
  "Snippet(sieve)": {
    "prefix": "sieve",
    "body": [
      "class Sieve {",
      "    long long n;",
      "    vector<long long> sieve;",
      "public:",
      "    Sieve (long long n): n(n), sieve(n+1) {",
      "        for (long long i=2; i<=n; ++i) {",
      "            if (sieve[i] != 0) continue;",
      "            sieve[i] = i;",
      "            for (long long k=i*i; k<=n; k+=i) {",
      "                if (sieve[k] == 0) sieve[k] = i;",
      "            }",
      "        }",
      "    }",
      "    bool is_prime(long long k) {",
      "        if (k <= 1 || k > n) return false;",
      "        if (sieve[k] == k) return true;",
      "        return false;",
      "    }",
      "    vector<pair<long long,long long>> factorize(long long k) {",
      "        vector<pair<long long,long long>> ret;",
      "        if (k <= 1 || k > n) return ret;",
      "        ret.emplace_back(sieve[k], 0);",
      "        while (k != 1) {",
      "            if (ret.back().first == sieve[k]) ++ret.back().second;",
      "            else ret.emplace_back(sieve[k], 1);",
      "            k /= sieve[k];",
      "        }",
      "        return ret;",
      "    }",
      "};"
    ]
  },
  "Snippet(rerooting)": {
    "prefix": "rerooting",
    "body": [
      "// Rerooting (snuke code + small modification)",
      "// https://youtu.be/zG1L4vYuGrg?t=7092",
      "// 注意: 辺や頂点に情報がある場合は使えない!!! ",
      "struct Rerooting {",
      "    struct DP {",
      "        // edit here (necessary data)",
      "        // ll x, t;",
      "         DP() {}  // edit here (initialization)",
      "        // DP(): x(0), t(0) {}",
      "        DP operator+(const DP &a) const {",
      "            DP ret;",
      "            // edit here",
      "            return ret;",
      "        }",
      "        DP goto_root() const {",
      "            DP ret;",
      "            // edit here",
      "            return ret;",
      "        }",
      "    };",
      "",
      "    int n;",
      "    vector<vector<int>> to;  // 隣接リスト  ",
      "    vector<vector<DP>> dp; // 頂点vから辺iで繋がる頂点からのdp値 ",
      "    vector<DP> ans;  // 頂点vからの求めたい値 ",
      "    Rerooting(int n) : n(n), to(n), dp(n), ans(n) {}  // constructor",
      "    void addEdge(int a, int b) {",
      "        to[a].push_back(b);",
      "        to[b].push_back(a);",
      "    }",
      "    void init() { dfs(0); bfs(0); }",
      "",
      "    DP dfs(int v, int p=-1) {  // 下向きのみ先に計算 ",
      "        DP dpSum;  // 下向きdpの合計 ",
      "        int deg = to[v].size();",
      "        dp[v].resize(deg);",
      "        for (int i=0; i<deg; ++i) {",
      "            int u = to[v][i];",
      "            if (u == p) continue;",
      "            dp[v][i] = dfs(u, v);  // uからのdpをdp[v][i]として保存（下向き） ",
      "                                   // 頂点uからの値であり、vはまだ含まれていない事に注意 ",
      "            dpSum = dpSum + dp[v][i];",
      "        }",
      "        return dpSum.goto_root();  // vを根として見たときのDPに変換してreturn",
      "    }",
      "    void bfs(int v, const DP &dpP=DP(), int p=-1) {  // 全方位 ",
      "        int deg = to[v].size();",
      "        for (int i=0; i<deg; ++i) {",
      "            if (to[v][i] == p) dp[v][i] = dpP;  // 親から上向きのdp",
      "        }",
      "        vector<DP> dpSumL(deg+1), dpSumR(deg+1);  // 累積和 ",
      "        for (int i=0; i<deg; ++i) dpSumL[i+1] = dpSumL[i] + dp[v][i];",
      "        for (int i=deg-1; i>=0; --i) dpSumR[i] = dpSumR[i+1] + dp[v][i];",
      "        ans[v] = dpSumL[deg].goto_root();  // 全足しして根をvとしたものに変換 ",
      "",
      "        for (int i=0; i<deg; ++i) {  // 下の頂点に潜るループ ",
      "            int u = to[v][i];",
      "            if (u == p) continue;",
      "            DP d = dpSumL[i] + dpSumR[i+1];  // remove dp[v][i]",
      "            bfs(u, d.goto_root(), v);  // d.goto_root()は、頂点vを根としたときの上側dpの値 ",
      "        }",
      "    }",
      "    DP get(int v) {return ans[v];}",
      "    // clip < ***.cppでの文字化け注意! ",
      "};"
    ]
  },
  "Snippet(lazy_segtree)": {
    "prefix": "lazy_segtree",
    "body": [
      "vector<S> v(N, {});"
      "lazy_segtree<S,op,e,F,mapping,composition,id> seg(v);"
    ]
  },
  "scc(Snippet)": {
    "prefix": "scc",
    "body": [
      "struct SCC {",
      "    SCC (long long _n): n(_n), from(_n), ifrom(_n) {}",
      "    void add_edge (long long a, long long b) {",
      "        from[a].push_back(b);",
      "        ifrom[b].push_back(a);",
      "    }",
      "    vector<vector<long long>> scc () {",
      "        vector<vector<long long>> group;",
      "        back_num.clear();",
      "        selected.assign(n, false);",
      "        for (long long i=0; i < n; ++i) {",
      "            if (!selected[i]) dfs1(i);",
      "        }",
      "        selected.assign(n, false);",
      "        for (long long i=n-1; i >= 0; --i) {",
      "            long long x = back_num[i];",
      "            if (selected[x]) continue;",
      "            vector<long long> emp;",
      "            dfs2(x, emp);",
      "            group.push_back(emp);",
      "        }",
      "        return group;",
      "    }",
      "private:",
      "    long long n;",
      "    vector<vector<long long>> from, ifrom;",
      "    vector<long long> back_num;",
      "    vector<bool> selected;",
      "    void dfs1 (long long x) {",
      "        selected[x] = true;",
      "        for (auto y: from[x]) {",
      "            if (selected[y]) continue;",
      "            dfs1(y);",
      "        }",
      "        back_num.push_back(x);",
      "    }",
      "    void dfs2 (long long x, vector<long long> &vec) {",
      "        selected[x] = true;",
      "        vec.push_back(x);",
      "        for (auto y: ifrom[x]) {",
      "            if (selected[y]) continue;",
      "            dfs2(y, vec);",
      "        }",
      "    }",
      "};",
    ],
  },
  "listup_divisor(Snippet)": {
    "prefix": "listup_divisor",
    "body": [
      "vector<long long> listup_divisor(long long x, bool issort=false) {",
      "    vector<long long> ret;",
      "    for(long long i=1; i*i<=x; ++i) {",
      "        if (x % i == 0) {",
      "            ret.push_back(i);",
      "            if (i*i != x) ret.push_back(x / i);",
      "        }",
      "    }",
      "    if (issort) sort(ret.begin(), ret.end());",
      "    return ret;",
      "}",
    ],
  },
  "Mersenne(Snippet)": {
    "prefix": "mersenne",
    "body": [
      "long long mersenne(long long mn, long long mx) {",
      "    static mt19937_64 mt64(0);",
      "    uniform_int_distribution<long long> get(mn, mx);",
      "    return get(mt64);",
      "}",
    ],
  },
  "run_length_encoding(Snippet)": {
    "prefix": "run_length_encoding",
    "body": [
      "vector<pair<char,long long>> run_length_encoding(string &s) {",
      "    vector<pair<char,long long>> ret;",
      "    char last_char = s[0]+1;",
      "    for (auto c: s) {",
      "        if (c != last_char) ret.emplace_back(c, 1);",
      "        else ++ret.back().second;",
      "        last_char = c;",
      "    }",
      "    return ret;",
      "}",
      "",
      "vector<pair<long long,long long>> run_length_encoding(vector<long long> &v) {",
      "    vector<pair<long long,long long>> ret;",
      "    long long last_num = v[0]+1;",
      "    for (auto x: v) {",
      "        if (x != last_num) ret.emplace_back(x, 1);",
      "        else ++ret.back().second;",
      "        last_num = x;",
      "    }",
      "    return ret;",
      "}",
    ],
  },
  "LCA": {
    "prefix": "lca",
    "body": [
      "using S = int;",
      "S op(S a, S b) {return min(a, b);}",
      "S e() {return 1001001001;}",
      "",
      "struct LCA {",
      "    int n, idx=0;",
      "    vector<int> et, in;",
      "    vector<long long> depth;",
      "    struct Edge {",
      "        int to, id;",
      "        long long w;",
      "    };",
      "    vector<vector<Edge>> from;",
      "    segtree<S,op,e> rmq;",
      "    LCA(long long n): n(n) {",
      "        from.resize(n);",
      "        in.resize(n);",
      "        depth.resize(n);",
      "    }",
      "    void add_edge(int a, int b, long long w=1) {",
      "        from[a].emplace_back(b, w, idx);",
      "        from[b].emplace_back(a, w, idx);",
      "        ++idx;",
      "    };",
      "    void euler_tour(int v=0) {",
      "        dfs(v);",
      "        rmq = segtree<S,op,e>(et.size());",
      "        for(int i=0; i<(int)et.size(); ++i) {",
      "            rmq.set(i, in[et[i]]);",
      "        }",
      "    }",
      "    void dfs(int v, long long d=0, int p=-1) {",
      "        in[v] = et.size();",
      "        depth[v] = d;",
      "        et.push_back(v);",
      "        for(auto [nv, w, id]: from[v]) if (nv != p) {",
      "            dfs(nv, d+w, v);",
      "            et.push_back(v);",
      "        }",
      "    }",
      "    int lca(int a, int b) {",
      "        int l = in[a], r = in[b];",
      "        if (l > r) swap(l, r);",
      "        return et[rmq.prod(l, r+1)];",
      "    }",
      "    long long dist(int a, int b) {",
      "        long long ret = 0;",
      "        int c = lca(a, b);",
      "        if (a!=c) ret += depth[a] - depth[c];",
      "        if (b!=c) ret += depth[b] - depth[c];",
      "        return ret;",
      "    }",
      "};",
      "",
    ],
  },
  "LCA2": {
    "prefix": "lca2",
    "body": [
      "using S = int;",
      "S op(S a, S b) {return min(a, b);}",
      "S e() {return 1001001001;}",
      "",
      "// LCA with online cost changes",
      "struct LCA2 {",
      "    int n, idx=0;",
      "    vector<int> et, in, ein, eout;  // EulerTour, in-order, edge-in-order, edge-out-order",
      "    vector<long long> depth, ws;  // depth, weights",
      "    struct Edge {",
      "        int to, id;",
      "        long long w;",
      "    };",
      "    vector<vector<Edge>> from;",
      "    segtree<S,op,e> rmq;",
      "    fenwick_tree<long long> tree;",
      "    LCA2(long long n): n(n) {",
      "        from.resize(n);",
      "        in.resize(n);",
      "        depth.resize(n);",
      "        ws.resize(n-1);",
      "        ein.resize(n-1);",
      "        eout.resize(n-1);",
      "    }",
      "    void add_edge(int a, int b, long long w=1) {",
      "        from[a].emplace_back(b, w, idx);",
      "        from[b].emplace_back(a, w, idx);",
      "        ws[idx] = w;",
      "        ++idx;",
      "    };",
      "    void euler_tour(int v=0) {",
      "        dfs(v);",
      "        rmq = segtree<S,op,e>(et.size());",
      "        tree = fenwick_tree<long long>(et.size());",
      "        for(int i=0; i<(int)et.size(); ++i) {",
      "            rmq.set(i, in[et[i]]);",
      "        }",
      "        for(int i=0; i<n-1; ++i) {",
      "            tree.add(ein[i], ws[i]);",
      "            tree.add(eout[i], -ws[i]);",
      "        }",
      "    }",
      "    void change_cost(int id, long long w) {",
      "        long long precost = ws[id];",
      "        long long dif = w - precost;",
      "        tree.add(ein[id], dif);",
      "        tree.add(eout[id], -dif);",
      "        ws[id] = w;",
      "    }",
      "    void dfs(int v, long long d=0, int p=-1) {",
      "        in[v] = et.size();",
      "        depth[v] = d;",
      "        et.push_back(v);",
      "        for(auto [nv, w, id]: from[v]) if (nv != p) {",
      "            ein[id] = et.size()-1;",
      "            dfs(nv, d+w, v);",
      "            eout[id] = et.size()-1;",
      "            et.push_back(v);",
      "        }",
      "    }",
      "    int lca(int a, int b) {",
      "        int l = in[a], r = in[b];",
      "        if (l > r) swap(l, r);",
      "        return et[rmq.prod(l, r+1)];",
      "    }",
      "    long long dist(int a, int b) {",
      "        long long ret = 0;",
      "        int c = lca(a, b);",
      "        if (a!=c) ret += depth[a] - depth[c];",
      "        if (b!=c) ret += depth[b] - depth[c];",
      "        return ret;",
      "    }",
      "    long long dist_with_changecost(int a, int b) {",
      "        long long ret = 0;",
      "        int c = lca(a, b);",
      "        if (a!=c) ret += tree.sum(in[c], in[a]);",
      "        if (b!=c) ret += tree.sum(in[c], in[b]);",
      "        return ret;",
      "    }",
      "};",
    ],
  },
  "atcoder_all(Snippet)": {
    "prefix": "at_all",
    "body": [
      "#include <atcoder/all>",
      "using namespace atcoder;",
      "using mint = modint998244353;",
      "using vm = vector<mint>;",
      "using vvm = vector<vector<mint>>;",
      "using vvvm = vector<vector<vector<mint>>>;",
      "inline void Out(mint e) {cout << e.val() << '\\\\n';}",
      "inline void Out(vm v) {rep(i,SIZE(v)) cout << v[i].val() << (i==SIZE(v)-1?'\\\\n':' ');}",
      "#ifdef __DEBUG",
      "inline void debug_view(mint e){cerr << e.val() << endl;}",
      "inline void debug_view(vm &v){for(auto e: v){cerr << e.val() << \" \";} cerr << endl;}",
      "inline void debug_view(vvm &vv){cerr << \"----\" << endl;for(auto &v: vv){debug_view(v);} cerr << \"--------\" << endl;}",
      "#endif",
    ],
  },
  "extgcd (Snippet)": {
    "prefix": "extgcd",
    "body": [
      "//! return {gcd(a,b), x, y}, where ax + by = gcd(a, b)"
      "//! IF a<0||b<0, gcd(a,b) COULD BE NEGATIVE VALUE!!!"
      "tuple<long long,long long,long long> extgcd(long long a, long long b) {",
      "    if (b == 0) return make_tuple(a, 1, 0);",
      "    auto [g, x, y] = extgcd(b, a%b);",
      "    return make_tuple(g, y, x - a/b*y);",
      "}",
      "",
    ],
  },
  "dprint (Snippet)": {
    "prefix": "dprint",
    "body": [
      "auto dprint=[&](){",
      "#ifdef __DEBUG",
      "    rep(i, N) {",
      "        cerr<<   <<' ';",
      "    }",
      "    cerr<<endl;",
      "#endif",
      "};",
    ],
  },
  "BidirectionalList": {
    "prefix": "bidirectional_list",
    "body": [
      "struct BidirectionalList {",
      "    const long long ninf = (long long)3e18;",
      "    unordered_map<long long,pair<long long,long long>> mp;",
      "    BidirectionalList () {",
      "        mp[-ninf] = {-ninf, ninf}; mp[ninf] = {-ninf, ninf};",
      "    }",
      "    void add_next(long long x, long long y) {  // put y after x",
      "        auto [p, n] = mp[x];",
      "        mp[x].second = y; mp[n].first = y;",
      "        mp[y] = {x, n};",
      "    }",
      "    void add_prev(long long x, long long y) {  // put y before x",
      "        auto [p, n] = mp[x];",
      "        mp[x].first = y; mp[p].second = y;",
      "        mp[y] = {p, x};",
      "    }",
      "    void add_head(long long x) { add_next(-ninf, x); }",
      "    void add_tail(long long x) { add_prev(ninf, x); }",
      "    pair<long long,long long> erase(long long x) {",
      "        auto [p, n] = mp[x];",
      "        mp[p].second = n; mp[n].first = p;",
      "        mp.erase(x);",
      "        return {p, n};",
      "    }",
      "    pair<long long,long long> get(long long x) { return mp[x]; }",
      "    void print() {",
      "        long long next = mp[-ninf].second;",
      "        vector<long long> vec;",
      "        while (next != ninf) {",
      "            vec.push_back(next);",
      "            next = mp[next].second;",
      "        }",
      "        for (int i=0; i<(int)vec.size(); ++i) {",
      "            cout << vec[i] << (i==(int)vec.size()-1?'\\\\n':' ');",
      "        }",
      "    }",
      "};",
    ],
  },
  "Combination2": {
    "prefix": "combination2",
    "body": [
      "//! Use this class if n >= 1e7 && r <= 1e6",
      "class Combination2 {",
      "    long long mod;",
      "public:",
      "    Combination2 (long long mod): mod(mod) {}",
      "    long long operator()(long long n, long long r) {",
      "        r = min(n-r , r);",
      "        long long r_fact = 1;",
      "        for (long long i=1; i<=r; ++i) (r_fact *= i) %= mod;",
      "        long long r_fact_inv = modpow(r_fact, mod-2, mod);",
      "        long long ret = r_fact_inv;",
      "        for (long long i=0; i<r; ++i) (ret *= (n-i)) %= mod;",
      "        return ret;",
      "    }",
      "    long long modpow(long long a, long long b, long long mod) {",
      "        long long ret = 1;",
      "        a %= mod;",
      "        while (b > 0) {",
      "            if ((b & 1) == 1) ret = ret * a % mod;",
      "            a = a * a % mod;",
      "            b = (b >> 1);",
      "        }",
      "        return ret;",
      "    }",
      "};",
    ],
  },
  "from(Snippet)": {
    "prefix": "fromsni",
    "body": [
      "vvl from(N);",
      "rep(i, $1) {",
      "    LONGM(a, b);"
      "    from[a].emplace_back(b);",
      "    from[b].emplace_back(a);",
      "}",
    ],
  },
  "trie(Snippet)": {
    "prefix": "trie",
    "body": [
      "/* Trie 木： 文字の種類(char_size)、int型で0に対応する文字(base)",
      "    insert(word): 単語 word を Trie 木に挿入する",
      "    search(word): 単語 word が Trie 木にあるか判定する",
      "    start_with(prefix):  prefix が一致する単語が Trie 木にあるか判定する",
      "    count(): 挿入した単語の数を返す",
      "    size(): Trie 木の頂点数を返す",
      "    計算量: insert, search ともに O(M)（Mは単語の長さ）",
      "    説明: https://algo-logic.info/trie-tree/",
      "*/",
      "template <int char_size, int base>",
      "struct Trie {",
      "    struct Node {            // 頂点を表す構造体",
      "        vector<int> next;    // 子の頂点番号を格納。存在しなければ-1",
      "        vector<int> accept;  // 末端がこの頂点になる単語の word_id を保存",
      "        int c;               // base からの間隔をint型で表現したもの",
      "        int common;          // いくつの単語がこの頂点を共有しているか",
      "        Node(int c_) : c(c_), common(0) {",
      "            next.assign(char_size, -1);",
      "        }",
      "    };",
      "    vector<Node> nodes;  // trie 木本体",
      "    int root;",
      "    Trie() : root(0) {",
      "        nodes.push_back(Node(root));",
      "    }",
      "    // 単語の挿入",
      "    void insert(const string &word, int word_id) {",
      "        int node_id = 0;",
      "        for (int i = 0; i < (int)word.size(); i++) {",
      "            int c = (int)(word[i] - base);",
      "            int &next_id = nodes[node_id].next[c];",
      "            if (next_id == -1) {  // 次の頂点が存在しなければ追加",
      "                next_id = (int)nodes.size();",
      "                nodes.push_back(Node(c));",
      "            }",
      "            ++nodes[node_id].common;",
      "            node_id = next_id;",
      "        }",
      "        ++nodes[node_id].common;",
      "        nodes[node_id].accept.push_back(word_id);",
      "    }",
      "    void insert(const string &word) {",
      "        insert(word, nodes[0].common);",
      "    }",
      "    // 単語とprefixの検索",
      "    bool search(const string &word, bool prefix = false) {",
      "        int node_id = 0;",
      "        for (int i = 0; i < (int)word.size(); i++) {",
      "            int c = (int)(word[i] - base);",
      "            int &next_id = nodes[node_id].next[c];",
      "            if (next_id == -1) {  // 次の頂点が存在しなければ終了",
      "                return false;",
      "            }",
      "            node_id = next_id;",
      "        }",
      "        return (prefix) ? true : nodes[node_id].accept.size() > 0;",
      "    }",
      "    // prefix を持つ単語が存在するかの検索",
      "    bool start_with(const string &prefix) {",
      "        return search(prefix, true);",
      "    }",
      "    // 挿入した単語の数",
      "    int count() const {",
      "        return (nodes[0].common);",
      "    }",
      "    // Trie木のノード数",
      "    int size() const {",
      "        return ((int)nodes.size());",
      "    }",
      "};",
      "",
    ],
  },
  "Spanbit(Snippet)": {
    "prefix": "spanbit",
    "body": [
      "template<typename T>",
      "class SpanBIT {",
      "    long long size;",
      "    vector<T> bit;",
      "    void _add (long long i, T x) {",
      "        if(i<0 || i>=size-1) assert(0&&\"Error: not 0<=i<=n in SpanBIT _add(i,x)\");",
      "        ++i;",
      "        for (; i<size; i+=i&-i) bit[i] += x;",
      "    }",
      "    T _sum (long long i) {",
      "        if(i<0 || i>=size-1) assert(0&&\"Error: not 0<=i<=n in SpanBIT _sum(i)\");",
      "        ++i;",
      "        T ret = 0;",
      "        for (; i>0; i-=i&-i) ret += bit[i];",
      "        return ret;",
      "    }",
      "public:",
      "    SpanBIT (long long _n): size(_n+2), bit(_n+2, 0) {}",
      "    // ![CAUTION]   0 <= l,r <= _n", 
      "    void add (long long l, long long r, T x) { // [l,r)",
      "        if(l<=r) {_add(l, x); _add(r, -x);}",
      "        else {",
      "            _add(l, x); _add(size-2, -x);",
      "            _add(0, x); _add(r, -x);",
      "        }",
      "    }",
      "    T get (long long i) {",
      "        return _sum(i);",
      "    }",
      "};",
    ],
  },
  "iota(Snippet)": {
    "prefix": "iotasni",
    "body": [
      "vl p(N);",
      "iota(all(p), 0);",
      "sort(all(p), [&](ll i, ll j){",
      "    $1",
      "});",
    ],
  },
  "mints(Snippet)": {
    "prefix": "mints",
    "body": [
      "const long long b = 12345;",
      "const long long MX = 3;",
      "const long long ps[12] = {1000000007, 1000000009, 1000000021,",
      "                          1000000033, 1000000087, 1000000093,",
      "                          1000000097, 1000000103, 1000000123,",
      "                          1000000181, 1000000207, 1000000223};",
      "struct mints {",
      "    long long data[MX];",
      "    mints(long long x=0) { for(int i=0; i<MX; ++i) data[i] = (x+ps[i])%ps[i]; }",
      "    mints operator+(mints x) const {",
      "        for(int i=0; i<MX; ++i) x.data[i] = (data[i]+x.data[i]) % ps[i];",
      "        return x;",
      "    }",
      "    mints &operator+=(mints x) { *this = *this + x; return *this; }",
      "    mints operator+(long long x) const { return *this + mints(x); }",
      "    mints operator-(mints x) const {",
      "        for(int i=0; i<MX; ++i) x.data[i] = (data[i]-x.data[i]+ps[i]) % ps[i];",
      "        return x;",
      "    }",
      "    mints &operator-=(mints x) { *this = *this - x; return *this; }",
      "    mints operator-(long long x) const { return *this - mints(x); }",
      "    mints operator*(mints x) const {",
      "        for(int i=0; i<MX; ++i) x.data[i] = data[i]*x.data[i]%ps[i];",
      "        return x;",
      "    }",
      "    mints &operator*=(mints x) { *this = *this * x; return *this; }",
      "    mints operator*(long long x) const { return *this * mints(x); }",
      "    mints pow(long long x) const {",
      "        if (x==0) return mints(1);",
      "        mints ret = pow(x/2);",
      "        ret = ret * ret;",
      "        if (x%2==1) ret = ret * *this;",
      "        return ret;",
      "    }",
      "    long long pow(long long a, long long b, long long p) const {",
      "        if(b==0) return 1;",
      "        a %= p;",
      "        long long ret = pow(a, b/2, p);",
      "        ret = ret * ret % p;",
      "        if (b%2==1) ret = ret * a % p;",
      "        return ret;",
      "    }",
      "    mints inv() const {",
      "        mints ret;",
      "        for(int i=0; i<MX; ++i) {",
      "            long long p = ps[i];",
      "            long long x = pow(data[i], p-2, p);",
      "            ret.data[i] = x;",
      "        }",
      "        return ret;",
      "    }",
      "    bool operator<(mints x) const {",
      "        for(int i=0; i<MX; ++i) if (data[i] != x.data[i]) {",
      "            return data[i] < x.data[i];",
      "        }",
      "        return false;",
      "    }",
      "    bool operator==(mints x) const {",
      "        for(int i=0; i<MX; ++i) if (data[i] != x.data[i]) return false;",
      "        return true;",
      "    }",
      "    void print() const {",
      "        for(int i=0; i<MX; ++i) cerr << data[i] << ' ';",
      "        cerr << '\\\\n';",
      "    }",
      "};",
      "",
      "namespace std {",
      "template<>",
      "struct hash<mints> {",
      "    size_t operator()(const mints &x) const {",
      "        size_t seed = 0;",
      "        for(int i=0; i<MX; ++i) {",
      "            hash<long long> phash;",
      "            seed ^= phash(x.data[i]) + 0x9e3779b9 + (seed << 6) + (seed >> 2);",
      "        }",
      "        return seed;",
      "    }",
      "};",
      "}",
    ],
  },
  "lowbou(Snipet)": {
    "prefix": "lowbou",
    "body": [
      "// return minimum index i where a[i] >= x, and its value a[i]",
      "// vector a must be pre-sorted in ascending (normal) order!",
      "// return value of a.size() means a.back() is not over x (a.back()<x)",
      "template<typename T>",
      "pair<long long,T> lowbou(vector<T> &a, T x) {",
      "    long long n = a.size();",
      "    T l = -1, r = n;",
      "    while (r - l > 1) {",
      "        T m = (l + r) / 2;",
      "        if (a[m] >= x) r = m;",
      "        else l = m;",
      "    }",
      "    if (r != n) return make_pair(r, a[r]);",
      "    else return make_pair(n, (T)3e18);",
      "}",
      "// return minimum index i where a[i] > x, and its value a[i]",
      "// vector a must be pre-sorted in ascending (normal) order!",
      "// return value of a.size() means a.back() is not over x (a.back()<=x)",
      "template<typename T>",
      "pair<long long,T> uppbou(vector<T> &a, T x) {",
      "    long long n = a.size();",
      "    T l = -1, r = n;",
      "    while (r - l > 1) {",
      "        T m = (l + r) / 2;",
      "        if (a[m] > x) r = m;",
      "        else l = m;",
      "    }",
      "    if (r != n) return make_pair(r, a[r]);",
      "    else return make_pair(n, (T)3e18);",
      "}",
      "// return maximum index i where a[i] <= x, and its value a[i]",
      "// vector a must be pre-sorted in ascending (normal) order!",
      "// return value of -1 means a[0] is already over x (a[0]>x)",
      "template<typename T>",
      "pair<long long,T> lowbou_r(vector<T> &a, T x) {",
      "    long long l = -1, r = a.size();",
      "    while (r - l > 1) {",
      "        T m = (l + r) / 2;",
      "        if (a[m] <= x) l = m;",
      "        else r = m;",
      "    }",
      "    if (l != -1) return make_pair(l, a[l]);",
      "    else return make_pair(-1, (T)-3e18);",
      "}",
      "// return maximum index i where a[i] < x, and its value a[i]",
      "// vector a must be pre-sorted in ascending (normal) order!",
      "// return value of -1 means a[0] is already over x (a[0]>=x)",
      "template<typename T>",
      "pair<long long,T> uppbou_r(vector<T> &a, T x) {",
      "    long long l = -1, r = a.size();",
      "    while (r - l > 1) {",
      "        T m = (l + r) / 2;",
      "        if (a[m] < x) l = m;",
      "        else r = m;",
      "    }",
      "    if (l != -1) return make_pair(l, a[l]);",
      "    else return make_pair(-1, (T)-3e18);",
      "}",
    ],
  },
  "binary_search(Snippet)": {
    "prefix": "binary_search",
    "body": [
      "long long binary_search (long long ok, long long ng, auto f) {",
      "    while (llabs(ok-ng) > 1) {",
      "        long long m = (ok + ng) / 2;",
      "        if (f(m)) ok = m;",
      "        else ng = m;",
      "    }",
      "    return ok;",
      "}",
      "//! For DOUBLE TYPE, PLEASE CAST THE TYPE OF INPUTS TO DOUBLE",
      "//! TO CORRECTLY INFER THE PROPER FUNCTION!!",
      "double binary_search (double ok, double ng, auto f) {",
      "    const int REPEAT = 100;",
      "    for(int i=0; i<=REPEAT; ++i) {",
      "        double m = (ok + ng) / 2;",
      "        if (f(m)) ok = m;",
      "        else ng = m;",
      "    }",
      "    return ok;",
      "}",
    ],
  },
  "dfs(Snippet)": {
    "prefix": "dfssni",
    "body": [
      "auto dfs = [&](auto f, ll v, ll p=-1) -> void {",
      "    for(auto nv: from[v]) if (nv != p) {",
      "",
      "    }",
      "};",
    ],
  },
  "atcoder/mint(Snippet)": {
    "prefix": "at_mint",
    "body": [
      "#include <atcoder/modint>",
      "using namespace atcoder;",
      "using mint = modint998244353;",
      "using vm = vector<mint>;",
      "using vvm = vector<vector<mint>>;",
      "using vvvm = vector<vector<vector<mint>>>;",
      "inline void Out(mint e) {cout << e.val() << '\\\\n';}",
      "inline void Out(vm v) {rep(i,SIZE(v)) cout << v[i].val() << (i==SIZE(v)-1?'\\\\n':' ');}",
      "#ifdef __DEBUG",
      "inline void debug_view(mint e){cerr << e.val() << endl;}",
      "inline void debug_view(vm &v){for(auto e: v){cerr << e.val() << \" \";} cerr << endl;}",
      "inline void debug_view(vvm &vv){cerr << \"----\" << endl;for(auto &v: vv){debug_view(v);} cerr << \"--------\" << endl;}",
      "#endif",
    ],
  },
  "atcoder/dsu(Snippet)": {
    "prefix": "at_dsu",
    "body": [
      "#include <atcoder/dsu>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/fenwick(Snippet)": {
    "prefix": "at_fenwick",
    "body": [
      "#include <atcoder/fenwicktree>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/segtree(Snippet)": {
    "prefix": "at_segtree",
    "body": [
      "#include <atcoder/segtree>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/lazysegtree(Snippet)": {
    "prefix": "at_lazysegtree",
    "body": [
      "#include <atcoder/lazysegtree>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/scc(Snippet)": {
    "prefix": "at_scc",
    "body": [
      "#include <atcoder/scc>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/math(Snippet)": {
    "prefix": "at_math",
    "body": [
      "#include <atcoder/math>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/string(Snippet)": {
    "prefix": "at_string",
    "body": [
      "#include <atcoder/string>",
      "using namespace atcoder;",
    ],
  },
  "Combination for small r(Snippet)": {
    "prefix": "ncr",
    "body": [
      "// Combination for very small r",
      "long long nCr (long long n, long long r) {",
      "    long long ninf = 3e18;",
      "    if(n<0 || r>n || r<0) return 0;",
      "    r = min(r, n-r);",
      "    long long ret = 1;",
      "    for(long long k=1; k<=r; ++k) {",
      "        if(n-k+1 > (ninf+ret-1)/ret) {",
      "            assert(0&&\"[Error:nCr] Too large return value.\");",
      "        }",
      "        ret *= n-k+1;",
      "        ret /= k;",
      "    }",
      "    return ret;",
      "}",
    ],
  },
  "Pascal(Snippet)": {
    "prefix": "pascal",
    "body": [
      "//! no mod nCr",
      "//! return value shall be within long long range",
      "class Pascal {",
      "    int mx = 66;",
      "    vector<vector<long long>> comb;",
      "public:",
      "    Pascal () :comb(mx+1, vector<long long>(mx+1)) {",
      "        comb[0][0] = 1;",
      "        for (int i=0; i<mx; ++i) for (int j=0; j<=i; ++j) {",
      "            comb[i+1][j] += comb[i][j];",
      "            comb[i+1][j+1] += comb[i][j];",
      "        }",
      "    }",
      "    long long nCr(int n, int r) {",
      "        if (n < 0 || r < 0 || n < r) return 0;",
      "        if (n > mx) {",
      "            cout << \"[ClassPascalError@nCr] n is too large (shall be <=66)\" << endl;",
      "            assert(0);",
      "        }",
      "        return comb[n][r];",
      "    }",
      "};",
    ],
  },
  "HeadK(Snipet)": {
    "prefix": "headk",
    "body": [
      "struct HeadK {",
      "    long long K, sum = 0;",
      "    bool ascending;",
      "    HeadK (long long K, bool ascending=true): K(K), ascending(ascending) {}",
      "    multiset<long long> stK, stM;",
      "    void add(long long x) {",
      "        if(!ascending) x = -x;",
      "        stK.insert(x);",
      "        sum += x;",
      "        KtoM();",
      "    };",
      "    void del(long long x) {",
      "        if(!ascending) x = -x;",
      "        if (stM.count(x)) {",
      "            stM.erase(stM.find(x));",
      "        } else {",
      "            if (!stK.count(x)) return;",
      "            auto it = stK.find(x);",
      "            stK.erase(it);",
      "            sum -= x;",
      "            while ((long long)stK.size()<K && stM.size()) {",
      "                auto it = stM.begin();",
      "                long long mn = *it;",
      "                stM.erase(it);",
      "                stK.insert(mn);",
      "                sum += mn;",
      "            }",
      "        }",
      "    }",
      "    void decK(long long nk) { // decrease K size",
      "        K = nk;",
      "        KtoM();",
      "    }",
      "    void KtoM() {",
      "        while ((long long)stK.size()>K) {",
      "            auto it = stK.end(); --it;",
      "            long long mx = *it;",
      "            stK.erase(it);",
      "            sum -= mx;",
      "            stM.insert(mx);",
      "        }",
      "    }",
      "    long long get_sum() {",
      "        if(ascending) return sum;",
      "        else return -sum;",
      "    }",
      "};",
    ],
  },
  "Fraction(Snippet)": {
    "prefix": "fraction",
    "body": [
      "//! BE CAREFUL ABOUT OVERFLOWING!",
      "//! repeated usage of +/* leads to overflowing",
      "struct Frac {",
      "    long long p, q;  // p/q: p over q (like y/x: y over x)",
      "    Frac(long long a=0, long long b=1) {",
      "        if (b == 0) {",
      "            p = 1; q = 0;  // inf (no definition of -inf)",
      "            return;",
      "        }",
      "        long long g = gcd(a, b);",
      "        p = a/g; q = b/g;",
      "        if (q<0) {p=-p; q=-q;}",
      "    }",
      "    Frac operator+(const Frac &rhs) {",
      "        if (q == 0 || rhs.q == 0) return Frac(1, 0);",
      "        return Frac(q*rhs.p + p*rhs.q, q*rhs.q);",
      "    }",
      "    Frac operator*(const Frac &rhs) {",
      "        if (q == 0 || rhs.q == 0) return Frac(1, 0);",
      "        return Frac(p*rhs.p, q*rhs.q);",
      "    }",
      "    bool operator<(const Frac &rhs) const {",
      "        return p*rhs.q - q*rhs.p < 0;",
      "    }",
      "    bool operator<=(const Frac &rhs) const {",
      "        return p*rhs.q - q*rhs.p <= 0;",
      "    }",
      "    bool operator>(const Frac &rhs) const {",
      "        return p*rhs.q - q*rhs.p > 0;",
      "    }",
      "    bool operator>=(const Frac &rhs) const {",
      "        return p*rhs.q - q*rhs.p >= 0;",
      "    }",
      "    bool operator==(const Frac &rhs) {",
      "        if (p==rhs.p && q==rhs.q) return true;",
      "        else return false;",
      "    }",
      "};",
    ],
  },
  "WeightedUnionFind(Snippet)": {
    "prefix": "unionfind",
    "body": [
      "struct WeightedUnionFind {",
      "    vector<long long> p, num, diff; vector<bool> inf;",
      "    WeightedUnionFind(long long n) : p(n,-1), num(n,1), diff(n), inf(n) {}",
      "    long long leader (long long x) {",
      "        if (p[x] == -1) return x;",
      "        long long y = p[x];",
      "        p[x] = leader(y);",
      "        diff[x] += diff[y];",
      "        return p[x];",
      "    }",
      "    bool merge (long long x, long long y, long long w=0) {   // x - y = w",
      "        leader(x); leader(y);  // path compression, -> diff will be based on root.",
      "        w = diff[y] - diff[x] - w;  // p[x]->x->y->p[y]",
      "        x = leader(x); y = leader(y);",
      "        if (x == y) {",
      "            if(w != 0) inf[x] = true;  // component x has infinite cycle",
      "            return w == 0;",
      "        }",
      "        if (size(x) > size(y)) swap(x, y), w = -w; // new parent = y",
      "        diff[x] = w;",
      "        p[x] = y;",
      "        num[y] += num[x];",
      "        if(inf[x]) inf[y] = true;",
      "        return true;",
      "        // merge関数はポテンシャルの差として引数を指定すれば良い",
      "        // yに対してxのポテンシャルはw大きい",
      "        // なお、diffは自分の親に移動した時のポテンシャル増加分を表すので",
      "        // diffが正であるとは、親よりもポテンシャルが低いという事",
      "        // （親ベースの増加分ではなく、それにマイナスをかけたもの）",
      "        // 従ってvのuに対するポテンシャルを求めたいのであれば",
      "        // diff[u]-diff[v]となる事に注意（感覚的には逆と思えてしまう）",
      "    }",
      "    bool same (long long x, long long y) { return leader(x) == leader(y); }",
      "    long long size (long long x) { return num[leader(x)]; }",
      "};",
    ],
  },
  "LazySegAffine(Snippet)": {
    "prefix": "affinesni",
    "body": [
      "// !Lazy Segtree for affine transformation",
      "// Edit here --> ",
      "using S = ll;",
      "S op(S a, S b) {return a+b;}",
      "S e() {return 0;}",
      "// <-- Edit here",
      "struct F {",
      "    ll a, b;",
      "    F(ll a, ll b):a(a), b(b) {}",
      "};",
      "S mapping(F f, S x) {",
      "    return f.a*x + f.b;",
      "}",
      "F composition(F f, F g) {",
      "    return F(f.a*g.a, f.a*g.b+f.b);",
      "}",
      "F id() {return F(1,0);}",
    ],
  },
  "digit(Snippet)": {
    "prefix": "digit",
    "body": [
      "vector<long long> separate_digit(long long x, long long base=10, long long sz=-1) {",
      "    vector<long long> ret;",
      "    while(x) {",
      "        ret.push_back(x%base);",
      "        x /= base;",
      "    }",
      "    if(sz!=-1) {",
      "        while((long long)ret.size()<sz) ret.push_back(0); // sz桁になるまで上桁を0埋め",
      "        while((long long)ret.size()>sz) ret.pop_back(); // 下sz桁を取り出す",
      "    }",
      "    reverse(ret.begin(), ret.end());",
      "    return ret;",
      "}",
      "",
      "long long consolidate_digit(vector<long long> a, long long base=10) {",
      "    long long ret = 0;",
      "    for(auto x: a) {",
      "        ret = ret*base + x;",
      "    }",
      "    return ret;",
      "}",
    ],
  },
}