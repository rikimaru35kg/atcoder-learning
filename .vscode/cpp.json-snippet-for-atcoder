{
  "Snippet(Combination)": {
    "prefix": "combination",
    "body": [
      "//! Only when <= 1e6",
      "//! If not, use Combination2 class below.",
      "class Combination {",
      "    long long mx, mod;",
      "    vector<long long> facts, ifacts;",
      "public:",
      "    // argument mod must be a prime number!!",
      "    Combination(long long mx, long long mod): mx(mx), mod(mod), facts(mx+1), ifacts(mx+1) {",
      "        facts[0] = 1;",
      "        for (long long i=1; i<=mx; ++i) facts[i] = facts[i-1] * i % mod;",
      "        ifacts[mx] = modpow(facts[mx], mod-2);",
      "        for (long long i=mx-1; i>=0; --i) ifacts[i] = ifacts[i+1] * (i+1) % mod;",
      "    }",
      "    long long operator()(long long n, long long r) {",
      "        if (r < 0 || r > n || n < 0 || n > mx) return 0;",
      "        return facts[n] * ifacts[r] % mod * ifacts[n-r] % mod;",
      "    }",
      "    long long nPr(long long n, long long r) {",
      "        if (r < 0 || r > n || n < 0 || n > mx) return 0;",
      "        return facts[n] * ifacts[n-r] % mod;",
      "    }",
      "    long long get_fact(long long n) {",
      "        if (n > mx) return 0;",
      "        return facts[n];",
      "    }",
      "    long long get_factinv(long long n) {",
      "        if (n > mx) return 0;",
      "        return ifacts[n];",
      "    }",
      "    long long modpow(long long a, long long b) {",
      "        if (b == 0) return 1;",
      "        a %= mod;",
      "        long long child = modpow(a, b/2);",
      "        if (b % 2 == 0) return child * child % mod;",
      "        else return a * child % mod * child % mod;",
      "    }",
      "};"
    ]
  },
  "Snippet(lower bound)": {
    "prefix": "lowbou",
    "body": [
      "// return minimum index i where a[i] >= x, and its value a[i]",
      "// vector a must be pre-sorted in ascending (normal) order!",
      "// return value of a.size() means a.back() is not over x (a.back()<x)",
      "pair<long long,long long> lowbou(vector<long long> &a, long long x) {",
      "    long long n = a.size();",
      "    long long l = -1, r = n;",
      "    while (r - l > 1) {",
      "        long long m = (l + r) / 2;",
      "        if (a[m] >= x) r = m;",
      "        else l = m;",
      "    }",
      "    if (r != n) return make_pair(r, a[r]);",
      "    else return make_pair(n, (long long)3e18);",
      "}",
      "// return minimum index i where a[i] > x, and its value a[i]",
      "// vector a must be pre-sorted in ascending (normal) order!",
      "// return value of a.size() means a.back() is not over x (a.back()<=x)",
      "pair<long long,long long> uppbou(vector<long long> &a, long long x) {",
      "    long long n = a.size();",
      "    long long l = -1, r = n;",
      "    while (r - l > 1) {",
      "        long long m = (l + r) / 2;",
      "        if (a[m] > x) r = m;",
      "        else l = m;",
      "    }",
      "    if (r != n) return make_pair(r, a[r]);",
      "    else return make_pair(n, (long long)3e18);",
      "}",
      "// return maximum index i where a[i] <= x, and its value a[i]",
      "// vector a must be pre-sorted in ascending (normal) order!",
      "// return value of -1 means a[0] is already over x (a[0]>x)",
      "pair<long long,long long> lowbou_r(vector<long long> &a, long long x) {",
      "    long long l = -1, r = a.size();",
      "    while (r - l > 1) {",
      "        long long m = (l + r) / 2;",
      "        if (a[m] <= x) l = m;",
      "        else r = m;",
      "    }",
      "    if (l != -1) return make_pair(l, a[l]);",
      "    else return make_pair(-1, (long long)-3e18);",
      "}",
      "// return maximum index i where a[i] < x, and its value a[i]",
      "// vector a must be pre-sorted in ascending (normal) order!",
      "// return value of -1 means a[0] is already over x (a[0]>=x)",
      "pair<long long,long long> uppbou_r(vector<long long> &a, long long x) {",
      "    long long l = -1, r = a.size();",
      "    while (r - l > 1) {",
      "        long long m = (l + r) / 2;",
      "        if (a[m] < x) l = m;",
      "        else r = m;",
      "    }",
      "    if (l != -1) return make_pair(l, a[l]);",
      "    else return make_pair(-1, (long long)-3e18);",
      "}"
    ]
  },
  "Snippet(Matrix)": {
    "prefix": "matrix",
    "body": [
      "//! n*n matrix",
      "//! Currently, only operator* is defined.",
      "template <typename T>",
      "class Mat {",
      "    long long n; vector<vector<T>> a; long long mod;",
      "public:",
      "    // Initialize n*n matrix",
      "    Mat (long long n, const vector<vector<T>> &mat={}, long long mod=-1)",
      "    : n(n), a(n, vector<T>(n)), mod(mod) {",
      "        // unit matrix if mat is not specified",
      "        if (mat.size() == 0) for (int i=0; i<n; ++i) a[i][i] = 1;",
      "        else {",
      "            for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "                a[i][j] = mat[i][j];",
      "                if (mod != -1) a[i][j] %= mod;",
      "            }",
      "        }",
      "    }",
      "    // Define operator*",
      "    Mat operator* (const Mat &rhs) {  // Mat * Mat",
      "        Mat ret(n);",
      "        if (mod != -1) ret = Mat(n, ret.a, mod);",
      "        ret.a.assign(n, vector<T>(n, 0));  // zero matrix",
      "        for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "            for (int k=0; k<n; ++k) {",
      "                ret.a[i][j] += a[i][k] * rhs.a[k][j];",
      "                if (mod != -1) ret.a[i][j] %= mod;",
      "            }",
      "        }",
      "        return ret;",
      "    }",
      "    vector<T> operator* (const vector<T> &rhs) {  // Mat * vector",
      "        vector<T> ret(n, 0);",
      "        for (int j=0; j<n; ++j) for (int k=0; k<n; ++k) {",
      "            ret[j] += a[j][k] * rhs[k];",
      "            if (mod != -1) ret[j] %= mod;",
      "        }",
      "        return ret;",
      "    }",
      "    // power k (A^k)",
      "    Mat pow(long long k) {",
      "        Mat ret = pow_recursive(*this, k);",
      "        return ret;",
      "    }",
      "    Mat pow_recursive(Mat b, long long k) {",
      "        Mat ret(n);",
      "        if (mod != -1) ret = Mat(n, ret.a, mod);",
      "        if (k == 0) return ret;",
      "        if (k%2 == 1) ret = b;",
      "        Mat tmp = pow_recursive(b, k/2);",
      "        return ret * tmp * tmp;",
      "    }",
      "    long long ij(long long i, long long j) {",
      "        return a[i][j];",
      "    }",
      "#ifdef __DEBUG",
      "    void print(string debugname=\"------\") {  // for debug",
      "        cerr << n << '\\n';",
      "        cerr << debugname << \":\\n\";",
      "        for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "            cerr << a[i][j] << (j==n-1? '\\n': ' ');",
      "        }",
      "        cerr << \"---------\" << '\\n';",
      "    }",
      "#else",
      "    void print(string debugname=\"------\") {}",
      "#endif",
      "};",
      ""
    ]
  },
  "Snippet(crop)": {
    "prefix": "crop",
    "body": [
      "//! Crop the rectangle that completely surrounds the specified",
      "//! character c.",
      "//! The rectangle just fits the character c area.",
      "//! (= The rectangle is selected so that the size is minimum.)",
      "vector<string> crop(vector<string> &field, char c='#') {",
      "    long long h = field.size();",
      "    long long w = field[0].size();",
      "    long long i_min = h, i_max = -1;",
      "    long long j_min = w, j_max = -1;",
      "    for(long long i=0; i<h; ++i) {",
      "        for(long long j=0; j<w; ++j) {",
      "            if (field[i][j] == c) {",
      "                i_min = min(i_min, i); i_max = max(i_max, i);",
      "                j_min = min(j_min, j); j_max = max(j_max, j);",
      "            }",
      "        }",
      "    }",
      "    vector<string> ret;",
      "    for(long long i=i_min; i<=i_max; ++i) {",
      "        ret.push_back(field[i].substr(j_min, j_max-j_min+1));",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(crop_out)": {
    "prefix": "crop_out",
    "body": [
      "//! Delete rows and columns that only include character c.",
      "vector<string> crop_out(vector<string> &field, char c='.') {",
      "    long long h = field.size();",
      "    long long w = field[0].size();",
      "    vector<bool> rows(h), cols(w); ",
      "    for(long long i=0; i<h; ++i) {",
      "        for(long long j=0; j<w; ++j) {",
      "            if (field[i][j] != c) {",
      "                rows[i] = true;",
      "                cols[j] = true;",
      "            }",
      "        }",
      "    }",
      "    vector<string> ret;",
      "    for(long long i=0; i<h; ++i) {",
      "        if (!rows[i]) continue;",
      "        ret.push_back(\"\");",
      "        for(long long j=0; j<w; ++j) {",
      "            if (cols[j]) ret.back() += field[i][j];",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(rot90)": {
    "prefix": "rot90",
    "body": [
      "//! Rotate field by +/-90deg",
      "vector<string> rot90(vector<string> &field, bool clockwise=true) {",
      "    long long h = field.size();",
      "    long long w = field[0].size();",
      "    vector<string> ret(w, string(h, ' '));",
      "    for (long long i=0; i<h; ++i) {",
      "        for (long long j=0; j<w; ++j) {",
      "            if (clockwise) ret[j][h-1-i] = field[i][j];",
      "            else ret[w-1-j][i] = field[i][j];",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(manhattan_dist)": {
    "prefix": "manhattan_dist",
    "body": [
      "//! Calculate Manhattan distance",
      "long long manhattan_dist(pair<long long,long long> p1, pair<long long,long long> p2) {",
      "    long long ret = 0;",
      "    ret += abs(p1.first - p2.first);",
      "    ret += abs(p1.second - p2.second);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(euclid_dist)": {
    "prefix": "euclid_dist",
    "body": [
      "//! Calculate Euclid distance",
      "//! input type = long long",
      "//! output type = double",
      "double euclid_dist(pair<long long,long long> p1, pair<long long,long long> p2) {",
      "    double ret = 0;",
      "    ret += (p1.first - p2.first) * (p1.first - p2.first);",
      "    ret += (p1.second - p2.second) * (p1.second - p2.second);",
      "    ret = sqrt(ret);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(euclid_distd)": {
    "prefix": "euclid_distd",
    "body": [
      "//! Calculate Euclid distance",
      "//! input type = double",
      "//! output type = double",
      "double euclid_distd(pair<double,double> p1, pair<double,double> p2) {",
      "    double ret = 0;",
      "    ret += (p1.first - p2.first) * (p1.first - p2.first);",
      "    ret += (p1.second - p2.second) * (p1.second - p2.second);",
      "    ret = sqrt(ret);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(euclid_dist2)": {
    "prefix": "euclid_dist2",
    "body": [
      "//! Calculate Euclid distance^2",
      "//! input type = long long",
      "//! output type = long long",
      "long long euclid_dist2(pair<long long,long long> p1, pair<long long,long long> p2) {",
      "    double ret = 0;",
      "    ret += (p1.first - p2.first) * (p1.first - p2.first);",
      "    ret += (p1.second - p2.second) * (p1.second - p2.second);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(coordinate_compression)": {
    "prefix": "coordinate_compression",
    "body": [
      "class CoordinateCompression {",
      "    bool oneindexed, init = false;",
      "    vector<long long> vec;",
      "public:",
      "    CoordinateCompression(bool one=false): oneindexed(one) {}",
      "    void add (long long x) {vec.push_back(x);}",
      "    void compress () {",
      "        sort(vec.begin(), vec.end());",
      "        vec.erase(unique(vec.begin(), vec.end()), vec.end());",
      "        init = true;",
      "    }",
      "    long long operator() (long long x) {",
      "        if (!init) compress();",
      "        long long ret = lower_bound(vec.begin(), vec.end(), x) - vec.begin();",
      "        if (oneindexed) ++ret;",
      "        return ret;",
      "    }",
      "    long long operator[] (long long i) {",
      "        if (!init) compress();",
      "        if (oneindexed) --i;",
      "        if (i < 0 || i >= (long long)vec.size()) return 3e18;",
      "        return vec[i];",
      "    }",
      "    long long size () {",
      "        if (!init) compress();",
      "        return (long long)vec.size();",
      "    }",
      "#ifdef __DEBUG",
      "    void print() {",
      "        printf(\"---- cc print ----\\ni: \");",
      "        for (long long i=0; i<(long long)vec.size(); ++i) printf(\"%2lld \", i);",
      "        printf(\"\\nx: \");",
      "        for (long long i=0; i<(long long)vec.size(); ++i) printf(\"%2lld \", vec[i]);",
      "        printf(\"\\n-----------------\\n\");",
      "    }",
      "#else",
      "    void print() {}",
      "#endif",
      "};"
    ]
  }
}