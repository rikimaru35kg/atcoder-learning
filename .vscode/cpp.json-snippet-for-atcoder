{
  "Snippet(crop)": {
    "prefix": "crop",
    "body": [
      "//! Crop the rectangle that completely surrounds the specified",
      "//! character c.",
      "//! The rectangle just fits the character c area.",
      "//! (= The rectangle is selected so that the size is minimum.)",
      "vector<string> crop(vector<string> &field, char c='#') {",
      "    long long h = field.size();",
      "    long long w = field[0].size();",
      "    long long i_min = h, i_max = -1;",
      "    long long j_min = w, j_max = -1;",
      "    for(long long i=0; i<h; ++i) {",
      "        for(long long j=0; j<w; ++j) {",
      "            if (field[i][j] == c) {",
      "                i_min = min(i_min, i); i_max = max(i_max, i);",
      "                j_min = min(j_min, j); j_max = max(j_max, j);",
      "            }",
      "        }",
      "    }",
      "    vector<string> ret;",
      "    for(long long i=i_min; i<=i_max; ++i) {",
      "        ret.push_back(field[i].substr(j_min, j_max-j_min+1));",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(crop_out)": {
    "prefix": "crop_out",
    "body": [
      "//! Delete rows and columns that only include character c.",
      "vector<string> crop_out(vector<string> &field, char c='.') {",
      "    long long h = field.size();",
      "    long long w = field[0].size();",
      "    vector<bool> rows(h), cols(w); ",
      "    for(long long i=0; i<h; ++i) {",
      "        for(long long j=0; j<w; ++j) {",
      "            if (field[i][j] != c) {",
      "                rows[i] = true;",
      "                cols[j] = true;",
      "            }",
      "        }",
      "    }",
      "    vector<string> ret;",
      "    for(long long i=0; i<h; ++i) {",
      "        if (!rows[i]) continue;",
      "        ret.push_back(\"\");",
      "        for(long long j=0; j<w; ++j) {",
      "            if (cols[j]) ret.back() += field[i][j];",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(rot90)": {
    "prefix": "rot90",
    "body": [
      "//! Rotate field by +/-90deg",
      "vector<string> rot90(vector<string> &field, bool clockwise=true) {",
      "    long long h = field.size();",
      "    long long w = field[0].size();",
      "    vector<string> ret(w, string(h, ' '));",
      "    for (long long i=0; i<h; ++i) {",
      "        for (long long j=0; j<w; ++j) {",
      "            if (clockwise) ret[j][h-1-i] = field[i][j];",
      "            else ret[w-1-j][i] = field[i][j];",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(manhattan_dist)": {
    "prefix": "manhattan_dist",
    "body": [
      "//! Calculate Manhattan distance",
      "long long manhattan_dist(pair<long long,long long> p1, pair<long long,long long> p2) {",
      "    long long ret = 0;",
      "    ret += abs(p1.first - p2.first);",
      "    ret += abs(p1.second - p2.second);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(euclid_dist)": {
    "prefix": "euclid_dist",
    "body": [
      "//! Calculate Euclid distance",
      "//! input type = long long",
      "//! output type = double",
      "double euclid_dist(pair<long long,long long> p1, pair<long long,long long> p2) {",
      "    double ret = 0;",
      "    ret += (p1.first - p2.first) * (p1.first - p2.first);",
      "    ret += (p1.second - p2.second) * (p1.second - p2.second);",
      "    ret = sqrt(ret);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(euclid_distd)": {
    "prefix": "euclid_distd",
    "body": [
      "//! Calculate Euclid distance",
      "//! input type = double",
      "//! output type = double",
      "double euclid_distd(pair<double,double> p1, pair<double,double> p2) {",
      "    double ret = 0;",
      "    ret += (p1.first - p2.first) * (p1.first - p2.first);",
      "    ret += (p1.second - p2.second) * (p1.second - p2.second);",
      "    ret = sqrt(ret);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(euclid_dist2)": {
    "prefix": "euclid_dist2",
    "body": [
      "//! Calculate Euclid distance^2",
      "//! input type = long long",
      "//! output type = long long",
      "long long euclid_dist2(pair<long long,long long> p1, pair<long long,long long> p2) {",
      "    long long ret = 0;",
      "    ret += (p1.first - p2.first) * (p1.first - p2.first);",
      "    ret += (p1.second - p2.second) * (p1.second - p2.second);",
      "    return ret;",
      "}"
    ]
  },
  "Snippet(prime_factorization)": {
    "prefix": "prime_factorization",
    "body": [
      "//! eg) 360 = 2^3 * 3^2 * 5^1;",
      "//! primes = {(2,3), (3,2), (5,1)}",
      "vector<pair<long long, long long>> prime_factorization (long long n) {",
      "    vector<pair<long long, long long>> primes;",
      "    if (n <= 1) return primes;",
      "    for (long long k=2; k*k<=n; ++k) {",
      "        if (n % k != 0) continue;",
      "        primes.emplace_back(k, 0);",
      "        while(n % k == 0) {",
      "            n /= k;",
      "            primes.back().second++;",
      "        }",
      "    }",
      "    if (n != 1) primes.emplace_back(n, 1);",
      "    return primes;",
      "}"
    ]
  },
  "Snippet(rerooting)": {
    "prefix": "rerooting",
    "body": [
      "// Rerooting (snuke code + small modification)",
      "// https://youtu.be/zG1L4vYuGrg?t=7092",
      "// 注意: 辺や頂点に情報がある場合は使えない!!! ",
      "struct Rerooting {",
      "    struct DP {",
      "        // edit here (necessary data)",
      "        // ll x, t;",
      "         DP() {}  // edit here (initialization)",
      "        // DP(): x(0), t(0) {}",
      "        DP operator+(const DP &a) const {",
      "            DP ret;",
      "            // edit here",
      "            return ret;",
      "        }",
      "        DP goto_root() const {",
      "            DP ret;",
      "            // edit here",
      "            return ret;",
      "        }",
      "    };",
      "",
      "    int n;",
      "    vector<vector<int>> to;  // 隣接リスト  ",
      "    vector<vector<DP>> dp; // 頂点vから辺iで繋がる頂点からのdp値 ",
      "    vector<DP> ans;  // 頂点vからの求めたい値 ",
      "    Rerooting(int n) : n(n), to(n), dp(n), ans(n) {}  // constructor",
      "    void addEdge(int a, int b) {",
      "        to[a].push_back(b);",
      "        to[b].push_back(a);",
      "    }",
      "    void init() { dfs(0); bfs(0); }",
      "",
      "    DP dfs(int v, int p=-1) {  // 下向きのみ先に計算 ",
      "        DP dpSum;  // 下向きdpの合計 ",
      "        int deg = to[v].size();",
      "        dp[v].resize(deg);",
      "        for (int i=0; i<deg; ++i) {",
      "            int u = to[v][i];",
      "            if (u == p) continue;",
      "            dp[v][i] = dfs(u, v);  // uからのdpをdp[v][i]として保存（下向き） ",
      "                                   // 頂点uからの値であり、vはまだ含まれていない事に注意 ",
      "            dpSum = dpSum + dp[v][i];",
      "        }",
      "        return dpSum.goto_root();  // vを根として見たときのDPに変換してreturn",
      "    }",
      "    void bfs(int v, const DP &dpP=DP(), int p=-1) {  // 全方位 ",
      "        int deg = to[v].size();",
      "        for (int i=0; i<deg; ++i) {",
      "            if (to[v][i] == p) dp[v][i] = dpP;  // 親から上向きのdp",
      "        }",
      "        vector<DP> dpSumL(deg+1), dpSumR(deg+1);  // 累積和 ",
      "        for (int i=0; i<deg; ++i) dpSumL[i+1] = dpSumL[i] + dp[v][i];",
      "        for (int i=deg-1; i>=0; --i) dpSumR[i] = dpSumR[i+1] + dp[v][i];",
      "        ans[v] = dpSumL[deg].goto_root();  // 全足しして根をvとしたものに変換 ",
      "",
      "        for (int i=0; i<deg; ++i) {  // 下の頂点に潜るループ ",
      "            int u = to[v][i];",
      "            if (u == p) continue;",
      "            DP d = dpSumL[i] + dpSumR[i+1];  // remove dp[v][i]",
      "            bfs(u, d.goto_root(), v);  // d.goto_root()は、頂点vを根としたときの上側dpの値 ",
      "        }",
      "    }",
      "    DP get(int v) {return ans[v];}",
      "    // clip < ***.cppでの文字化け注意! ",
      "};"
    ]
  },
  "Snippet(lazy_segtree)": {
    "prefix": "lazy_segtree",
    "body": [
      "vector<S> init(N, S(**));"
      "lazy_segtree<S,op,e,F,mapping,composition,id> seg(init);"
    ]
  },
  "scc(Snippet)": {
    "prefix": "scc",
    "body": [
      "struct SCC {",
      "    SCC (long long _n): n(_n), from(_n), ifrom(_n) {}",
      "    void add_edge (long long a, long long b) {",
      "        from[a].push_back(b);",
      "        ifrom[b].push_back(a);",
      "    }",
      "    vector<vector<long long>> scc () {",
      "        vector<vector<long long>> group;",
      "        back_num.clear();",
      "        selected.assign(n, false);",
      "        for (long long i=0; i < n; ++i) {",
      "            if (!selected[i]) dfs1(i);",
      "        }",
      "        selected.assign(n, false);",
      "        for (long long i=n-1; i >= 0; --i) {",
      "            long long x = back_num[i];",
      "            if (selected[x]) continue;",
      "            vector<long long> emp;",
      "            dfs2(x, emp);",
      "            group.push_back(emp);",
      "        }",
      "        return group;",
      "    }",
      "private:",
      "    long long n;",
      "    vector<vector<long long>> from, ifrom;",
      "    vector<long long> back_num;",
      "    vector<bool> selected;",
      "    void dfs1 (long long x) {",
      "        selected[x] = true;",
      "        for (auto y: from[x]) {",
      "            if (selected[y]) continue;",
      "            dfs1(y);",
      "        }",
      "        back_num.push_back(x);",
      "    }",
      "    void dfs2 (long long x, vector<long long> &vec) {",
      "        selected[x] = true;",
      "        vec.push_back(x);",
      "        for (auto y: ifrom[x]) {",
      "            if (selected[y]) continue;",
      "            dfs2(y, vec);",
      "        }",
      "    }",
      "};",
    ],
  },
  "listup_divisor(Snippet)": {
    "prefix": "listup_divisor",
    "body": [
      "vector<long long> listup_divisor(long long x, bool issort=false) {",
      "    vector<long long> ret;",
      "    for(long long i=1; i*i<=x; ++i) {",
      "        if (x % i == 0) {",
      "            ret.push_back(i);",
      "            if (i*i != x) ret.push_back(x / i);",
      "        }",
      "    }",
      "    if (issort) sort(ret.begin(), ret.end());",
      "    return ret;",
      "}",
    ],
  },
  "Mersenne(Snippet)": {
    "prefix": "mersenne",
    "body": [
      "long long mersenne(long long mn, long long mx) {",
      "    static mt19937_64 mt64(0);",
      "    uniform_int_distribution<long long> get(mn, mx);",
      "    return get(mt64);",
      "}",
    ],
  },
  "LCA": {
    "prefix": "lca",
    "body": [
      "using S = int;",
      "S op(S a, S b) {return min(a, b);}",
      "S e() {return 1001001001;}",
      "",
      "struct LCA {",
      "    int n, idx=0;",
      "    vector<int> et, in;",
      "    vector<long long> depth;",
      "    struct Edge {",
      "        int to, id;",
      "        long long w;",
      "    };",
      "    vector<vector<Edge>> from;",
      "    segtree<S,op,e> rmq;",
      "    LCA(long long n): n(n) {",
      "        from.resize(n);",
      "        in.resize(n);",
      "        depth.resize(n);",
      "    }",
      "    void add_edge(int a, int b, long long w=1) {",
      "        from[a].emplace_back(b, w, idx);",
      "        from[b].emplace_back(a, w, idx);",
      "        ++idx;",
      "    };",
      "    void euler_tour(int v=0) {",
      "        dfs(v);",
      "        rmq = segtree<S,op,e>(et.size());",
      "        for(int i=0; i<(int)et.size(); ++i) {",
      "            rmq.set(i, in[et[i]]);",
      "        }",
      "    }",
      "    void dfs(int v, long long d=0, int p=-1) {",
      "        in[v] = et.size();",
      "        depth[v] = d;",
      "        et.push_back(v);",
      "        for(auto [nv, w, id]: from[v]) if (nv != p) {",
      "            dfs(nv, d+w, v);",
      "            et.push_back(v);",
      "        }",
      "    }",
      "    int lca(int a, int b) {",
      "        int l = in[a], r = in[b];",
      "        if (l > r) swap(l, r);",
      "        return et[rmq.prod(l, r+1)];",
      "    }",
      "    long long dist(int a, int b) {",
      "        long long ret = 0;",
      "        int c = lca(a, b);",
      "        if (a!=c) ret += depth[a] - depth[c];",
      "        if (b!=c) ret += depth[b] - depth[c];",
      "        return ret;",
      "    }",
      "};",
      "",
    ],
  },
  "atcoder_all(Snippet)": {
    "prefix": "at_all",
    "body": [
      "#include <atcoder/all>",
      "using namespace atcoder;",
      "using mint = modint998244353;",
      "using vm = vector<mint>;",
      "using vvm = vector<vector<mint>>;",
      "using vvvm = vector<vector<vector<mint>>>;",
      "inline void Out(mint e) {cout << e.val() << '\\\\n';}",
      "inline void Out(vm v) {rep(i,SIZE(v)) cout << v[i].val() << (i==SIZE(v)-1?'\\\\n':' ');}",
      "#ifdef __DEBUG",
      "inline void debug_view(mint e){cerr << e.val() << endl;}",
      "inline void debug_view(vm &v){for(auto e: v){cerr << e.val() << \" \";} cerr << endl;}",
      "inline void debug_view(vvm &vv){cerr << \"----\" << endl;for(auto &v: vv){debug_view(v);} cerr << \"--------\" << endl;}",
      "#endif",
    ],
  },
  "extgcd (Snippet)": {
    "prefix": "extgcd",
    "body": [
      "//! return {gcd(a,b), x, y}, where ax + by = gcd(a, b)"
      "//! IF a<0||b<0, gcd(a,b) COULD BE NEGATIVE VALUE!!!"
      "tuple<long long,long long,long long> extgcd(long long a, long long b) {",
      "    if (b == 0) return make_tuple(a, 1, 0);",
      "    auto [g, x, y] = extgcd(b, a%b);",
      "    return make_tuple(g, y, x - a/b*y);",
      "}",
      "",
    ],
  },
  "BidirectionalList": {
    "prefix": "bidirectional_list",
    "body": [
      "struct BidirectionalList {",
      "    const long long ninf = (long long)3e18;",
      "    unordered_map<long long,pair<long long,long long>> mp;",
      "    BidirectionalList () {",
      "        mp[-ninf] = {-ninf, ninf}; mp[ninf] = {-ninf, ninf};",
      "    }",
      "    void add_next(long long x, long long y) {  // put y after x",
      "        auto [p, n] = mp[x];",
      "        mp[x].second = y; mp[n].first = y;",
      "        mp[y] = {x, n};",
      "    }",
      "    void add_prev(long long x, long long y) {  // put y before x",
      "        auto [p, n] = mp[x];",
      "        mp[x].first = y; mp[p].second = y;",
      "        mp[y] = {p, x};",
      "    }",
      "    void add_head(long long x) { add_next(-ninf, x); }",
      "    void add_tail(long long x) { add_prev(ninf, x); }",
      "    pair<long long,long long> erase(long long x) {",
      "        auto [p, n] = mp[x];",
      "        mp[p].second = n; mp[n].first = p;",
      "        mp.erase(x);",
      "        return {p, n};",
      "    }",
      "    pair<long long,long long> get(long long x) { return mp[x]; }",
      "    void print() {",
      "        long long next = mp[-ninf].second;",
      "        vector<long long> vec;",
      "        while (next != ninf) {",
      "            vec.push_back(next);",
      "            next = mp[next].second;",
      "        }",
      "        for (int i=0; i<(int)vec.size(); ++i) {",
      "            cout << vec[i] << (i==(int)vec.size()-1?'\\\\n':' ');",
      "        }",
      "    }",
      "};",
    ],
  },
  "Combination2": {
    "prefix": "combination2",
    "body": [
      "//! Use this class if n >= 1e7 && r <= 1e6",
      "class Combination2 {",
      "    long long mod;",
      "public:",
      "    Combination2 (long long mod): mod(mod) {}",
      "    long long operator()(long long n, long long r) {",
      "        r = min(n-r , r);",
      "        long long r_fact = 1;",
      "        for (long long i=1; i<=r; ++i) (r_fact *= i) %= mod;",
      "        long long r_fact_inv = modpow(r_fact, mod-2, mod);",
      "        long long ret = r_fact_inv;",
      "        for (long long i=0; i<r; ++i) (ret *= (n-i)) %= mod;",
      "        return ret;",
      "    }",
      "    long long modpow(long long a, long long b, long long mod) {",
      "        long long ret = 1;",
      "        a %= mod;",
      "        while (b > 0) {",
      "            if ((b & 1) == 1) ret = ret * a % mod;",
      "            a = a * a % mod;",
      "            b = (b >> 1);",
      "        }",
      "        return ret;",
      "    }",
      "};",
    ],
  },
  "from(Snippet)": {
    "prefix": "fromsni",
    "body": [
      "vvl from(N);",
      "rep(i, $1) {",
      "    LONGM(a, b);"
      "    from[a].emplace_back(b);",
      "    from[b].emplace_back(a);",
      "}",
    ],
  },
  "Snippet(SpanBIT)": {
    "prefix": "spanbit",
    "body": [
      "template<typename T>",
      "class SpanBIT {",
      "    long long size;",
      "    vector<T> bit;",
      "    void _add (long long i, T x) {",
      "        if(i<0 || i>=size-1) assert(0&&\"Error: not 0<=i<=n in SpanBIT _add(i,x)\");",
      "        ++i;",
      "        for (; i<size; i+=i&-i) bit[i] += x;",
      "    }",
      "    T _sum (long long i) {",
      "        if(i<0 || i>=size-1) assert(0&&\"Error: not 0<=i<=n in SpanBIT _sum(i)\");",
      "        ++i;",
      "        T ret = 0;",
      "        for (; i>0; i-=i&-i) ret += bit[i];",
      "        return ret;",
      "    }",
      "public:",
      "    SpanBIT (long long _n): size(_n+2), bit(_n+2, 0) {}",
      "    // ![CAUTION]   0 <= l,r <= _n", 
      "    void add (long long l, long long r, T x) { // [l,r)",
      "        if(l<=r) {_add(l, x); _add(r, -x);}",
      "        else {",
      "            _add(l, x); _add(size-2, -x);",
      "            _add(0, x); _add(r, -x);",
      "        }",
      "    }",
      "    T get (long long i) {",
      "        return _sum(i);",
      "    }",
      "};",
    ],
  },
  "iota(Snippet)": {
    "prefix": "iotasni",
    "body": [
      "vl p(N);",
      "iota(all(p), 0);",
      "sort(all(p), [&](ll i, ll j){",
      "    $1",
      "});",
    ],
  },
  "mints(Snippet)": {
    "prefix": "mints",
    "body": [
      "const long long base = 12345;",
      "const long long MX = 2;",
      "const long long ps[12] = {1000000007, 1000000009, 1000000021,",
      "                          1000000033, 1000000087, 1000000093,",
      "                          1000000097, 1000000103, 1000000123,",
      "                          1000000181, 1000000207, 1000000223};",
      "struct mints {",
      "    long long data[MX];",
      "    mints(long long x=0) { for(int i=0; i<MX; ++i) data[i] = (x+ps[i])%ps[i]; }",
      "    mints operator+(mints x) const {",
      "        for(int i=0; i<MX; ++i) x.data[i] = (data[i]+x.data[i]) % ps[i];",
      "        return x;",
      "    }",
      "    mints &operator+=(mints x) { *this = *this + x; return *this; }",
      "    mints operator+(long long x) const { return *this + mints(x); }",
      "    mints operator-(mints x) const {",
      "        for(int i=0; i<MX; ++i) x.data[i] = (data[i]-x.data[i]+ps[i]) % ps[i];",
      "        return x;",
      "    }",
      "    mints &operator-=(mints x) { *this = *this - x; return *this; }",
      "    mints operator-(long long x) const { return *this - mints(x); }",
      "    mints operator*(mints x) const {",
      "        for(int i=0; i<MX; ++i) x.data[i] = data[i]*x.data[i]%ps[i];",
      "        return x;",
      "    }",
      "    mints &operator*=(mints x) { *this = *this * x; return *this; }",
      "    mints operator*(long long x) const { return *this * mints(x); }",
      "    mints pow(long long x) const {",
      "        if (x==0) return mints(1);",
      "        mints ret = pow(x/2);",
      "        ret = ret * ret;",
      "        if (x%2==1) ret = ret * *this;",
      "        return ret;",
      "    }",
      "    long long pow(long long a, long long b, long long p) const {",
      "        if(b==0) return 1;",
      "        a %= p;",
      "        long long ret = pow(a, b/2, p);",
      "        ret = ret * ret % p;",
      "        if (b%2==1) ret = ret * a % p;",
      "        return ret;",
      "    }",
      "    mints inv() const {",
      "        mints ret;",
      "        for(int i=0; i<MX; ++i) {",
      "            long long p = ps[i];",
      "            long long x = pow(data[i], p-2, p);",
      "            ret.data[i] = x;",
      "        }",
      "        return ret;",
      "    }",
      "    bool operator<(mints x) const {",
      "        for(int i=0; i<MX; ++i) if (data[i] != x.data[i]) {",
      "            return data[i] < x.data[i];",
      "        }",
      "        return false;",
      "    }",
      "    bool operator==(mints x) const {",
      "        for(int i=0; i<MX; ++i) if (data[i] != x.data[i]) return false;",
      "        return true;",
      "    }",
      "    void print() const {",
      "        for(int i=0; i<MX; ++i) cerr << data[i] << ' ';",
      "        cerr << '\\\\n';",
      "    }",
      "};",
      "",
      "namespace std {",
      "template<>",
      "struct hash<mints> {",
      "    size_t operator()(const mints &x) const {",
      "        size_t seed = 0;",
      "        for(int i=0; i<MX; ++i) {",
      "            hash<long long> phash;",
      "            seed ^= phash(x.data[i]) + 0x9e3779b9 + (seed << 6) + (seed >> 2);",
      "        }",
      "        return seed;",
      "    }",
      "};",
      "}",
    ],
  },
  "dfs(Snippet)": {
    "prefix": "dfssni",
    "body": [
      "auto dfs = [&](auto f, ll v, ll p=-1) -> void {",
      "    for(auto nv: from[v]) if (nv != p) {",
      "",
      "    }",
      "};",
    ],
  },
  "atcoder/mint(Snippet)": {
    "prefix": "at_mint",
    "body": [
      "#include <atcoder/modint>",
      "using namespace atcoder;",
      "using mint = modint998244353;",
      "using vm = vector<mint>;",
      "using vvm = vector<vector<mint>>;",
      "using vvvm = vector<vector<vector<mint>>>;",
      "inline void Out(mint e) {cout << e.val() << '\\\\n';}",
      "inline void Out(vm v) {rep(i,SIZE(v)) cout << v[i].val() << (i==SIZE(v)-1?'\\\\n':' ');}",
      "#ifdef __DEBUG",
      "inline void debug_view(mint e){cerr << e.val() << endl;}",
      "inline void debug_view(vm &v){for(auto e: v){cerr << e.val() << \" \";} cerr << endl;}",
      "inline void debug_view(vvm &vv){cerr << \"----\" << endl;for(auto &v: vv){debug_view(v);} cerr << \"--------\" << endl;}",
      "#endif",
    ],
  },
  "atcoder/dsu(Snippet)": {
    "prefix": "at_dsu",
    "body": [
      "#include <atcoder/dsu>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/fenwick(Snippet)": {
    "prefix": "at_fenwick",
    "body": [
      "#include <atcoder/fenwicktree>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/segtree(Snippet)": {
    "prefix": "at_segtree",
    "body": [
      "#include <atcoder/segtree>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/lazysegtree(Snippet)": {
    "prefix": "at_lazysegtree",
    "body": [
      "#include <atcoder/lazysegtree>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/scc(Snippet)": {
    "prefix": "at_scc",
    "body": [
      "#include <atcoder/scc>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/math(Snippet)": {
    "prefix": "at_math",
    "body": [
      "#include <atcoder/math>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/string(Snippet)": {
    "prefix": "at_string",
    "body": [
      "#include <atcoder/string>",
      "using namespace atcoder;",
    ],
  },
  "atcoder/convolution(Snippet)": {
    "prefix": "at_conv",
    "body": [
      "#include<atcoder/convolution>",
      "using namespace atcoder;",
    ],
  },
  "Pascal(Snippet)": {
    "prefix": "pascal",
    "body": [
      "//! no mod nCr",
      "//! return value shall be within long long range",
      "class Pascal {",
      "    int mx = 66;",
      "    vector<vector<long long>> comb;",
      "public:",
      "    Pascal () :comb(mx+1, vector<long long>(mx+1)) {",
      "        comb[0][0] = 1;",
      "        for (int i=0; i<mx; ++i) for (int j=0; j<=i; ++j) {",
      "            comb[i+1][j] += comb[i][j];",
      "            comb[i+1][j+1] += comb[i][j];",
      "        }",
      "    }",
      "    long long nCr(int n, int r) {",
      "        if (n < 0 || r < 0 || n < r) return 0;",
      "        if (n > mx) {",
      "            cout << \"[ClassPascalError@nCr] n is too large (shall be <=66)\" << endl;",
      "            assert(0);",
      "        }",
      "        return comb[n][r];",
      "    }",
      "};",
    ],
  },
  "LazySegAffine(Snippet)": {
    "prefix": "affinesni",
    "body": [
      "// !Lazy Segtree for affine transformation",
      "// Edit here --> ",
      "using S = ll;",
      "S op(S a, S b) {return a+b;}",
      "S e() {return 0;}",
      "// <-- Edit here",
      "struct F {",
      "    ll a, b;",
      "    F(ll a, ll b):a(a), b(b) {}",
      "};",
      "S mapping(F f, S x) {",
      "    return f.a*x + f.b;",
      "}",
      "F composition(F f, F g) {",
      "    return F(f.a*g.a, f.a*g.b+f.b);",
      "}",
      "F id() {return F(1,0);}",
    ],
  },
  "modpow(Snippet)": {
    "prefix": "modpow",
    "body": [
      "//! Calculate mod(a^b, mod)",
      "//! a >= 0, b >= 0, mod > 0;",
      "long long modpow(long long a, long long b, long long mod) {",
      "    long long ans = 1;",
      "    a %= mod;",
      "    while (b > 0) {",
      "        if ((b & 1) == 1) {",
      "            ans = ans * a % mod;",
      "        }",
      "        a = a * a % mod;",
      "        b = (b >> 1);",
      "    }",
      "    return ans;",
      "}",
      "",
      "//! Calculate a^b",
      "//! a >= 0, b >= 0",
      "long long spow(long long a, long long b) {",
      "    long long ans = 1;",
      "    while (b > 0) {",
      "        if ((b & 1) == 1) {",
      "            ans = ans * a;",
      "        }",
      "        a = a * a;",
      "        b = (b >> 1);",
      "    }",
      "    return ans;",
      "}",
    ],
  },
  "DEBUG NOTION(Snippet)": {
    "prefix": "DDDDD",
    "body": [
      "// =============================================================",
      "//  DO NOT FORGET TO UNDO THE DEBUG CHANGES!!",
      "// =============================================================",
    ],
  },
  "Snippet(dij)": {
    "prefix": "dijsni",
    "body": [
      "for(auto [di,dj]: dij) {",
      "    ll ni = i + di, nj = j + dj;",
      "    if(!isin(ni,nj,$1,$2)) continue;",
      "}",
    ],
  },
  "Snippet(Kth-root)": {
    "prefix": "kth_root",
    "body": [
      "//! n,k >= 0",
      "//! O(log kM) M=3e18",
      "long long kth_root(long long n, long long k) {",
      "    if(k<=0 || n<0) assert(0&&\"[Error]k<=0 or n<0 in the function of kth_root.\");",
      "    auto f=[&](long long x) -> bool {",
      "        long long x_to_kpow = 1;",
      "        for(long long i=0; i<k; ++i) {",
      "            if(x>n/x_to_kpow) return false;",
      "            x_to_kpow *= x;",
      "        }",
      "        return x_to_kpow <= n;",
      "    };",
      "    long long l = 0, r = 3e18;",
      "    while(r-l>1) {",
      "        long long m = (l+r)/2;",
      "        if(f(m)) l = m;",
      "        else r = m;",
      "    }",
      "    return l;",
      "}",
    ],
  },
  "Snippet(listup combinations)": {
    "prefix": "listup_combinations",
    "body": [
      "//! [Danger] might lead to RE because of too large return size.",
      "//! Caululate size of nCk * k beforehand.",
      "vector<vector<int>> listup_combinations(int n, int k) {",
      "    vector<vector<int>> ret;",
      "    auto f=[&](auto f, int i=0, vector<int> &v) -> void {",
      "        if((int)v.size()==k) {",
      "            ret.push_back(v);",
      "            return;",
      "        }",
      "        if(i>=n) return;",
      "        f(f, i+1, v);",
      "        v.push_back(i);",
      "        f(f, i+1, v);",
      "        v.pop_back();",
      "    };",
      "    vector<int> v={};",
      "    f(f, 0, v);",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(digit)": {
    "prefix": "digit",
    "body": [
      "vector<long long> separate_digit(long long x, long long base=10, long long sz=-1) {",
      "    vector<long long> ret;",
      "    if(x==0) ret.push_back(0);",
      "    while(x) {",
      "        ret.push_back(x%base);",
      "        x /= base;",
      "    }",
      "    if(sz!=-1) {",
      "        while((long long)ret.size()<sz) ret.push_back(0); // sz桁になるまで上桁を0埋め",
      "        while((long long)ret.size()>sz) ret.pop_back(); // 下sz桁を取り出す",
      "    }",
      "    reverse(ret.begin(), ret.end());",
      "    return ret;",
      "}",
      "",
      "long long consolidate_digit(vector<long long> a, long long base=10) {",
      "    long long ret = 0;",
      "    for(auto x: a) {",
      "        ret = ret*base + x;",
      "    }",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(Run Length Encoding)": {
    "prefix": "run_length_encoding",
    "body": [
      "vector<pair<char,long long>> run_length_encoding(string &s) {",
      "    vector<pair<char,long long>> ret;",
      "    for(auto c: s) {",
      "        if(ret.size() && ret.back().first==c) ret.back().second++;",
      "        else ret.emplace_back(c, 1);",
      "    }",
      "    return ret;",
      "}",
      "",
      "vector<pair<long long,long long>> run_length_encoding(vector<long long> &v) {",
      "    vector<pair<long long,long long>> ret;",
      "    long long last_num = v[0]+1;",
      "    for (auto x: v) {",
      "        if (x != last_num) ret.emplace_back(x, 1);",
      "        else ++ret.back().second;",
      "        last_num = x;",
      "    }",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(HeadK)": {
    "prefix": "headk",
    "body": [
      "struct HeadK {",
      "    long long K, sum = 0;",
      "    bool ascending;",
      "    HeadK (long long K, bool ascending=true): K(K), ascending(ascending) {}",
      "    multiset<long long> stK, stM;",
      "    void add(long long x) {",
      "        if(!ascending) x = -x;",
      "        stK.insert(x);",
      "        sum += x;",
      "        KtoM();",
      "    };",
      "    void del(long long x) {",
      "        if(!ascending) x = -x;",
      "        if (stM.contains(x)) {",
      "            stM.erase(stM.find(x));",
      "        } else {",
      "            if (!stK.contains(x)) return;",
      "            stK.erase(stK.find(x));",
      "            sum -= x;",
      "            while ((long long)stK.size()<K && stM.size()) {",
      "                auto it = stM.begin();",
      "                long long mn = *it;",
      "                stM.erase(it);",
      "                stK.insert(mn);",
      "                sum += mn;",
      "            }",
      "        }",
      "    }",
      "    void decK(long long nk) { // decrease K size",
      "        K = nk;",
      "        KtoM();",
      "    }",
      "    void KtoM() {",
      "        while ((long long)stK.size()>K) {",
      "            auto it = stK.end(); --it;",
      "            long long mx = *it;",
      "            stK.erase(it);",
      "            sum -= mx;",
      "            stM.insert(mx);",
      "        }",
      "    }",
      "    long long get_sum() {",
      "        if(ascending) return sum;",
      "        else return -sum;",
      "    }",
      "};",
    ],
  },
  "Snippet(split)": {
    "prefix": "split",
    "body": [
      "vector<string> split(string &s, char t) {",
      "    vector<string> ret; string now;",
      "    for(auto c: s) {",
      "        if(c==t) {",
      "            if(now.size()) ret.push_back(now);",
      "            now = \"\";",
      "        } else now += c;",
      "    }",
      "    if(now.size()) ret.push_back(now);",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(maxflow)": {
    "prefix": "at_flow",
    "body": [
      "#include <atcoder/maxflow>",
      "using namespace atcoder;",
    ],
  },
  "Snippet(unique)": {
    "prefix": "unique",
    "body": [
      "template<typename T> void unique(vector<T> &v) {",
      "    sort(v.begin(), v.end());",
      "    v.erase(unique(v.begin(), v.end()), v.end());",
      "}",
    ],
  },
  "Snippet(pset[pbds])": {
    "prefix": "pset_pbds",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "template <class T>",
      "using pset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "",
    ],
  },
  "Snippet(Binary Search)": {
    "prefix": "binary_search",
    "body": [
      "long long binary_search (long long ok, long long ng, auto f) {",
      "    while (llabs(ok-ng) > 1) {",
      "        ll l = min(ok, ng), r = max(ok, ng);",
      "        long long m = l + (r-l)/2;",
      "        if (f(m)) ok = m;",
      "        else ng = m;",
      "    }",
      "    return ok;",
      "}",
      "//! For DOUBLE TYPE, PLEASE CAST THE TYPE OF INPUTS TO DOUBLE",
      "//! TO CORRECTLY INFER THE PROPER FUNCTION!!",
      "double binary_search (double ok, double ng, auto f) {",
      "    const int REPEAT = 100;",
      "    for(int i=0; i<=REPEAT; ++i) {",
      "        double m = (ok + ng) / 2;",
      "        if (f(m)) ok = m;",
      "        else ng = m;",
      "    }",
      "    return ok;",
      "}",
    ],
  },
  "Snippet(vector)": {
    "prefix": "vector",
    "body": [
      "// Vector",
      "const double eps = 1e-8; // suppose max(x,y) <= 1e9;",
      "struct Vec {",
      "    double x, y;",
      "    Vec(double x=0, double y=0): x(x), y(y) {}",
      "    Vec& operator+=(const Vec& v) { x += v.x; y += v.y; return *this;}",
      "    Vec operator+(const Vec& v) const { return Vec(*this) += v;}",
      "    Vec& operator-=(const Vec& v) { x -= v.x; y -= v.y; return *this;}",
      "    Vec operator-(const Vec& v) const { return Vec(*this) -= v;}",
      "    Vec& operator*=(double s) { x *= s; y *= s; return *this;}",
      "    Vec operator*(double s) const { return Vec(*this) *= s;}",
      "    Vec& operator/=(double s) { x /= s; y /= s; return *this;}",
      "    Vec operator/(double s) const { return Vec(*this) /= s;}",
      "    double dot(const Vec& v) const { return x*v.x + y*v.y;}",
      "    // cross>0 means *this->v is counterclockwise.",
      "    double cross(const Vec& v) const { return x*v.y - v.x*y;}",
      "    double norm2() const { return x*x + y*y;}",
      "    double norm() const { return sqrt(norm2());}",
      "    Vec normalize() const { return *this/norm();}",
      "    Vec rotate90() const { return Vec(y, -x);}",
      "    void rotate(double theta) {",
      "        Vec ret;",
      "        ret.x = cos(theta)*x - sin(theta)*y;",
      "        ret.y = sin(theta)*x + cos(theta)*y;",
      "        *this = ret;",
      "    }",
      "    int ort() const { // orthant",
      "    if (abs(x) < eps && abs(y) < eps) return 0;",
      "    if (y > 0) return x>0 ? 1 : 2;",
      "    else return x>0 ? 4 : 3;",
      "    }",
      "    bool operator<(const Vec& v) const {",
      "      int o = ort(), vo = v.ort();",
      "      if (o != vo) return o < vo;",
      "      return cross(v) > 0;",
      "    }",
      "};",
      "istream& operator>>(istream& is, Vec& v) {",
      "    is >> v.x >> v.y; return is;",
      "}",
      "ostream& operator<<(ostream& os, const Vec& v) {",
      "    os<<\"(\"<<v.x<<\",\"<<v.y<<\")\"; return os;",
      "}",
    ],
  },
  "Snippet(gid)": {
    "prefix": "gid",
    "body": [
      "auto gid=[&](ll i, ll j) {return i*$1+j;};",
      "auto rid=[&](ll id) -> Pr {return {id/$1, id%$1};};",
    ],
  },
  "Snippet(LCA w/ online cost change)": {
    "prefix": "lca2",
    "body": [
      "#include <atcoder/segtree>",
      "#include <atcoder/fenwicktree>",
      "using namespace atcoder;",
      "",
      "using S = int;",
      "S op(S a, S b) {return min(a, b);}",
      "S e() {return 1001001001;}",
      "",
      "// LCA with online cost changes",
      "struct LCA2 {",
      "    int n, idx=0;",
      "    vector<int> et, in, ein, eout;  // EulerTour, in-order, edge-in-order, edge-out-order",
      "    vector<long long> depth, ws;  // depth, weights",
      "    struct Edge {",
      "        int to, id;",
      "        long long w;",
      "    };",
      "    vector<vector<Edge>> from;",
      "    segtree<S,op,e> rmq;",
      "    fenwick_tree<long long> tree;",
      "    LCA2(long long n): n(n) {",
      "        from.resize(n);",
      "        in.resize(n);",
      "        depth.resize(n);",
      "        ws.resize(n-1);",
      "        ein.resize(n-1);",
      "        eout.resize(n-1);",
      "    }",
      "    void add_edge(int a, int b, long long w=1) {",
      "        from[a].emplace_back(b, w, idx);",
      "        from[b].emplace_back(a, w, idx);",
      "        ws[idx] = w;",
      "        ++idx;",
      "    };",
      "    void euler_tour(int v=0) {",
      "        dfs(v);",
      "        rmq = segtree<S,op,e>(et.size());",
      "        tree = fenwick_tree<long long>(et.size());",
      "        for(int i=0; i<(int)et.size(); ++i) {",
      "            rmq.set(i, in[et[i]]);",
      "        }",
      "        for(int i=0; i<n-1; ++i) {",
      "            tree.add(ein[i], ws[i]);",
      "            tree.add(eout[i], -ws[i]);",
      "        }",
      "    }",
      "    void change_cost(int id, long long w) {",
      "        long long precost = ws[id];",
      "        long long dif = w - precost;",
      "        tree.add(ein[id], dif);",
      "        tree.add(eout[id], -dif);",
      "        ws[id] = w;",
      "    }",
      "    void dfs(int v, long long d=0, int p=-1) {",
      "        in[v] = et.size();",
      "        depth[v] = d;",
      "        et.push_back(v);",
      "        for(auto [nv, w, id]: from[v]) if (nv != p) {",
      "            ein[id] = et.size()-1;",
      "            dfs(nv, d+w, v);",
      "            eout[id] = et.size()-1;",
      "            et.push_back(v);",
      "        }",
      "    }",
      "    int lca(int a, int b) {",
      "        int l = in[a], r = in[b];",
      "        if (l > r) swap(l, r);",
      "        return et[rmq.prod(l, r+1)];",
      "    }",
      "    long long dist(int a, int b) {",
      "        long long ret = 0;",
      "        int c = lca(a, b);",
      "        if (a!=c) ret += depth[a] - depth[c];",
      "        if (b!=c) ret += depth[b] - depth[c];",
      "        return ret;",
      "    }",
      "    long long dist_with_changecost(int a, int b) {",
      "        long long ret = 0;",
      "        int c = lca(a, b);",
      "        if (a!=c) ret += tree.sum(in[c], in[a]);",
      "        if (b!=c) ret += tree.sum(in[c], in[b]);",
      "        return ret;",
      "    }",
      "};",
    ],
  },
  "Snippet(Coordinate Compression)": {
    "prefix": "coordinate_compression",
    "body": [
      "template <typename T>",
      "class CoordinateCompression {",
      "    bool oneindexed, init = false;",
      "    vector<T> vec;",
      "public:",
      "    CoordinateCompression(bool one=false): oneindexed(one) {}",
      "    void add (T x) {vec.push_back(x);}",
      "    void compress () {",
      "        sort(vec.begin(), vec.end());",
      "        vec.erase(unique(vec.begin(), vec.end()), vec.end());",
      "        init = true;",
      "    }",
      "    long long operator() (T x) {",
      "        if (!init) compress();",
      "        long long ret = lower_bound(vec.begin(), vec.end(), x) - vec.begin();",
      "        if (oneindexed) ++ret;",
      "        return ret;",
      "    }",
      "    T operator[] (long long i) {",
      "        if (!init) compress();",
      "        if (oneindexed) --i;",
      "        if (i < 0 || i >= (long long)vec.size()) return T();",
      "        return vec[i];",
      "    }",
      "    long long size () {",
      "        if (!init) compress();",
      "        return (long long)vec.size();",
      "    }",
      "#ifdef __DEBUG",
      "    void print() {",
      "        printf(\"---- cc print ----\\\\ni: \");",
      "        for (long long i=0; i<(long long)vec.size(); ++i) printf(\"%2lld \", i);",
      "        printf(\"\\\\nx: \");",
      "        for (long long i=0; i<(long long)vec.size(); ++i) printf(\"%2lld \", vec[i]);",
      "        printf(\"\\\\n-----------------\\\\n\");",
      "    }",
      "#else",
      "    void print() {}",
      "#endif",
      "};",
    ],
  },
  "Snippet(dprint)": {
    "prefix": "dprint",
    "body": [
      "auto dprint=[&](){",
      "#ifdef __DEBUG",
      "    de(\"-- dprint --\")",
      "    rep(i, N) fprintf(stderr, \" \");",
      "    cerr<<endl;",
      "#endif",
      "};",
    ],
  },
  "Snippet(segprint)": {
    "prefix": "segprint",
    "body": [
      "auto segprint=[&](){",
      "#ifdef __DEBUG",
      "    de(\"-- segprint --\")",
      "    ll sz = seg.max_right(0,[](S x)->bool{return true;});",
      "    rep(i, sz) fprintf(stderr, \"%lld \", seg.get(i));",
      "    cerr<<endl;",
      "#endif",
      "};",
    ],
  },
  "Snippet(tree dfs)": {
    "prefix": "treesni",
    "body": [
      "auto dfs=[&](auto f, ll v, ll p=-1) -> void {",
      "    for(auto nv: from[v]) if(nv!=p) {",
      "        f(f, nv, v);",
      "    }",
      "};",
    ],
  },
  "Snippet(lowbou)": {
    "prefix": "lowbou",
    "body": [
      "// return minimum index i where a[i] >= x, and its value a[i]",
      "template<typename T>",
      "pair<long long,T> lowbou(vector<T> &a, T x, bool ascending=true) {",
      "    long long n = a.size();",
      "    long long l = -1, r = n;",
      "    while (r - l > 1) {",
      "        long long m = (l + r) / 2;",
      "        if(ascending) {",
      "            if (a[m] >= x) r = m;",
      "            else l = m;",
      "        } else {",
      "            if (a[m] <= x) r = m;",
      "            else l = m;",
      "        }",
      "    }",
      "    if (r != n) return make_pair(r, a[r]);",
      "    else return make_pair(n, T());",
      "}",
      "// return minimum index i where a[i] > x, and its value a[i]",
      "template<typename T>",
      "pair<long long,T> uppbou(vector<T> &a, T x, bool ascending=true) {",
      "    long long n = a.size();",
      "    long long l = -1, r = n;",
      "    while (r - l > 1) {",
      "        long long m = (l + r) / 2;",
      "        if(ascending) {",
      "            if (a[m] > x) r = m;",
      "            else l = m;",
      "        } else {",
      "            if (a[m] < x) r = m;",
      "            else l = m;",
      "        }",
      "    }",
      "    if (r != n) return make_pair(r, a[r]);",
      "    else return make_pair(n, T());",
      "}",
      "// return maximum index i where a[i] <= x, and its value a[i]",
      "template<typename T>",
      "pair<long long,T> lowbou_r(vector<T> &a, T x, bool ascending=true) {",
      "    long long l = -1, r = a.size();",
      "    while (r - l > 1) {",
      "        long long m = (l + r) / 2;",
      "        if(ascending) {",
      "            if (a[m] <= x) l = m;",
      "            else r = m;",
      "        } else {",
      "            if (a[m] >= x) l = m;",
      "            else r = m;",
      "        }",
      "    }",
      "    if (l != -1) return make_pair(l, a[l]);",
      "    else return make_pair(-1, T());",
      "}",
      "// return maximum index i where a[i] < x, and its value a[i]",
      "template<typename T>",
      "pair<long long,T> uppbou_r(vector<T> &a, T x, bool ascending=true) {",
      "    long long l = -1, r = a.size();",
      "    while (r - l > 1) {",
      "        long long m = (l + r) / 2;",
      "        if(ascending) {",
      "            if (a[m] < x) l = m;",
      "            else r = m;",
      "        } else {",
      "            if (a[m] > x) l = m;",
      "            else r = m;",
      "        }",
      "    }",
      "    if (l != -1) return make_pair(l, a[l]);",
      "    else return make_pair(-1, T());",
      "}",
    ],
  },
  "Snippet(ledendre_formula)": {
    "prefix": "legendre_formula",
    "body": [
      "long long legendre_formula(long long n, long long x) {",
      "    if(x<=0) assert(0&&\"[Error] ledendre_formula x<=0\");",
      "    if(x==1) return (long long)3e18;",
      "    long long ret = 0;",
      "    while(n) {",
      "        ret += n/x;",
      "        n /= x;",
      "    }",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(lessthan)": {
    "prefix": "lessthan",
    "body": [
      "//! judge x + y <= z (or x + y < z)",
      "//! where x^2, y^2, z^2 are provided",
      "//! [NOTE] (x2,y2,z2<=1e9) to avoid overflowing",
      "bool lessthan(long long x2, long long y2, long long z2, bool eq) {",
      "    long long d = z2-x2-y2;",
      "    if(d<0) return false;",
      "    if(eq) return 4*x2*y2 <= d*d;",
      "    else return 4*x2*y2 < d*d;",
      "}",
    ],
  },
  "Snippet(lucas)": {
    "prefix": "lucas",
    "body": [
      "// Combination for very small r",
      "long long nCr (long long n, long long r) {",
      "    long long ninf = 9e18;",
      "    if(n<0 || r>n || r<0) return 0;",
      "    r = min(r, n-r);",
      "    long long ret = 1;",
      "    for(long long k=1; k<=r; ++k) {",
      "        if(n-k+1 > (ninf+ret-1)/ret) {",
      "            assert(0&&\"[Error:nCr] Too large return value.\");",
      "        }",
      "        ret *= n-k+1;",
      "        ret /= k;",
      "    }",
      "    return ret;",
      "}",
      "",
      "long long lucas(long long n, long long r, long long m) {",
      "    if(n<0 || r>n || r<0) return 0;",
      "    long long ret = 1;",
      "    while(n || r) {",
      "        (ret *= nCr(n%m, r%m)) %= m;",
      "        n /= m, r /= m;",
      "    }",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(get_line)": {
    "prefix": "line",
    "body": [
      "tuple<long long,long long,long long> get_line(pair<long long,long long> p1, pair<long long,long long> p2) {",
      "    if(p1==p2) assert(0&&\"[Error] get_line() same point for p1 & p2\");",
      "    auto [x1,y1] = p1; auto [x2,y2] = p2;",
      "    long long a = 0, b = 0, c = 0;",
      "    a = y2-y1, b = -(x2-x1), c = -x1*y2+y1*x2;",
      "    long long g = gcd(gcd(a,b),c);",
      "    a /= g, b /= g, c /= g;",
      "    if(a==0 && b<0) b=-b, c=-c;",
      "    if(a<0) a=-a, b=-b, c=-c;",
      "    return {a,b,c};",
      "}",
    ],
  },
  "Snippet(calmex)": {
    "prefix": "calmex",
    "body": [
      "long long calmex(vector<long long> &x) {",
      "    long long N = SIZE(x);",
      "    vector<bool> used(N);",
      "    for(long long i=0; i<N; ++i) if(x[i]<N) used[x[i]] = true;",
      "    long long ret = 0;",
      "    while(ret<N && used[ret]) ++ret;",
      "    return ret;",
      "};",
    ],
  },
  "Snippet(Excel String)": {
    "prefix": "excel",
    "body": [
      "//! Change 26 to an appropriate number",
      "string excel_string(long long n, char base='A') {",
      "    const long long m = 26;",
      "    string ret;",
      "    while(n) {",
      "        --n;",
      "        ret += n%m + base;",
      "        n /= m;",
      "    }",
      "    reverse(all(ret));",
      "    return ret;",
      "}",
      "long long num_of_excel_string(string s, char base='A') {",
      "    const long long m = 26;",
      "    long long ret = 0;",
      "    for(auto c: s) {",
      "        ret = ret*m + c-base + 1;",
      "    }",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(Vector double)": {
    "prefix": "vectord",
    "body": [
      "const double eps = 1e-8; // suppose max(x,y) <= 1e6;",
      "struct Vecd {",
      "    double x, y;",
      "    Vecd(double x=0, double y=0): x(x), y(y) {}",
      "    Vecd& operator+=(const Vecd& v) { x += v.x; y += v.y; return *this;}",
      "    Vecd operator+(const Vecd& v) const { return Vecd(*this) += v;}",
      "    Vecd& operator-=(const Vecd& v) { x -= v.x; y -= v.y; return *this;}",
      "    Vecd operator-(const Vecd& v) const { return Vecd(*this) -= v;}",
      "    Vecd& operator*=(double s) { x *= s; y *= s; return *this;}",
      "    Vecd operator*(double s) const { return Vecd(*this) *= s;}",
      "    Vecd& operator/=(double s) { x /= s; y /= s; return *this;}",
      "    Vecd operator/(double s) const { return Vecd(*this) /= s;}",
      "    double dot(const Vecd& v) const { return x*v.x + y*v.y;}",
      "    // cross>0 means *this->v is counterclockwise.",
      "    double cross(const Vecd& v) const { return x*v.y - v.x*y;}",
      "    double norm2() const { return x*x + y*y;}",
      "    double norm() const { return sqrt(norm2());}",
      "    Vecd normalize() const { return *this/norm();}",
      "    Vecd rotate90() const { return Vecd(y, -x);}",
      "    void rotate(double theta) {",
      "        Vecd ret;",
      "        ret.x = cos(theta)*x - sin(theta)*y;",
      "        ret.y = sin(theta)*x + cos(theta)*y;",
      "        *this = ret;",
      "    }",
      "    int ort() const { // orthant",
      "    if (abs(x) < eps && abs(y) < eps) return 0;",
      "    if (y > 0) return x>0 ? 1 : 2;",
      "    else return x>0 ? 4 : 3;",
      "    }",
      "    bool operator<(const Vecd& v) const {",
      "      int o = ort(), vo = v.ort();",
      "      if (o != vo) return o < vo;",
      "      return cross(v) > 0;",
      "    }",
      "};",
      "istream& operator>>(istream& is, Vecd& v) {",
      "    is >> v.x >> v.y; return is;",
      "}",
      "ostream& operator<<(ostream& os, const Vecd& v) {",
      "    os<<\"(\"<<v.x<<\",\"<<v.y<<\")\"; return os;",
      "}",
    ],
  },
  "Snippet(que print)": {
    "prefix": "queprint",
    "body": [
      "auto queprint=[&]() {",
      "#ifdef __DEBUG",
      "    vp save;",
      "    while(que.size()) {",
      "        auto [a,b] = que.top(); que.pop();",
      "        fprintf(stderr, \"{%lld,%lld} \", a, b);",
      "        save.emplace_back(a, b);",
      "    }",
      "    cerr<<endl;",
      "    while(save.size()) {",
      "        auto [a, b] = save.back(); save.pop_back();",
      "        que.emplace(a, b);",
      "    }",
      "#endif",
      "};",
    ],
  },
  "Snippet(Combination)": {
    "prefix": "combination",
    "body": [
      "//! Only when <= 1e6",
      "//! If not, use Combination2 class below.",
      "class Combination {",
      "    long long mx, mod;",
      "    vector<long long> facts, ifacts;",
      "public:",
      "    // argument mod must be a prime number!!",
      "    Combination(long long mx, long long mod): mx(mx), mod(mod), facts(mx+1), ifacts(mx+1) {",
      "        facts[0] = 1;",
      "        for (long long i=1; i<=mx; ++i) facts[i] = facts[i-1] * i % mod;",
      "        ifacts[mx] = modpow(facts[mx], mod-2);",
      "        for (long long i=mx-1; i>=0; --i) ifacts[i] = ifacts[i+1] * (i+1) % mod;",
      "    }",
      "    long long operator()(long long n, long long r) {",
      "        return nCr(n, r);",
      "    }",
      "    long long nCr(long long n, long long r) {",
      "        if(n>mx) assert(0&&\"[Error@Combination] n>mx\");",
      "        if (r < 0 || r > n || n < 0) return 0;",
      "        return facts[n] * ifacts[r] % mod * ifacts[n-r] % mod;",
      "    }",
      "    long long nPr(long long n, long long r) {",
      "        if(n>mx) assert(0&&\"[Error@Combination] n>mx\");",
      "        if (r < 0 || r > n || n < 0) return 0;",
      "        return facts[n] * ifacts[n-r] % mod;",
      "    }",
      "    long long nHr(long long n, long long r, bool one=false) {",
      "        if(!one) return nCr(n+r-1, r);",
      "        else return nCr(r-1, n-1);",
      "    }",
      "    long long get_fact(long long n) {",
      "        if(n>mx) assert(0&&\"[Error@Combination] n>mx\");",
      "        return facts[n];",
      "    }",
      "    long long get_factinv(long long n) {",
      "        if(n>mx) assert(0&&\"[Error@Combination] n>mx\");",
      "        return ifacts[n];",
      "    }",
      "    long long modpow(long long a, long long b) {",
      "        if (b == 0) return 1;",
      "        a %= mod;",
      "        long long child = modpow(a, b/2);",
      "        if (b % 2 == 0) return child * child % mod;",
      "        else return a * child % mod * child % mod;",
      "    }",
      "};",
    ],
  },
  "Snippet(LIS length)": {
    "prefix": "lis",
    "body": [
      "template <typename T>",
      "long long lis_length(vector<T> &a) {",
      "    int n = a.size(), ret = 0;",
      "    vector<T> v(n, (ll)3e18);",
      "    for(int i=0; i<n; ++i) {",
      "        int idx = lower_bound(v.begin(), v.end(), a[i]) - v.begin();",
      "        v[idx] = a[i];",
      "        ret = max(ret, idx+1);",
      "    }",
      "    return ret;",
      "}",
      "template <typename T>",
      "long long dis_length(vector<T> &a) {",
      "    vector<T> b = a;",
      "    for(auto &x: b) x = -x;",
      "    long long ret = lis_length(b);",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(transpose)": {
    "prefix": "transpose",
    "body": [
      "vector<string> transpose(vector<string> &s) {",
      "    long long h = s.size(), w = s[0].size();",
      "    vector<string> ret(w, string(h, '.'));",
      "    for(long long i=0; i<h; ++i) for(long long j=0; j<w; ++j) {",
      "        ret[j][i] = s[i][j];",
      "    }",
      "    return ret;",
      "}",
      "template <typename T>",
      "vector<vector<T>> transpose(vector<vector<T>> &a) {",
      "    int h = a.size(), w = a[0].size();",
      "    vector<vector<T>> ret(w, vector<T>(h));",
      "    for(int i=0; i<h; ++i) for(int j=0; j<w; ++j) {",
      "        ret[j][i] = a[i][j];",
      "    }",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(dpush)": {
    "prefix": "dpush",
    "body": [
      "auto dpush=[&](ll a, ll b, ll c) {",
      "    from[a].emplace_back(b, c);",
      "    from[b].emplace_back(a, c);",
      "};",
    ],
  },
  "Snippet(WeightedUnionFind)": {
    "prefix": "unionfind",
    "body": [
      "struct WeightedUnionFind {",
      "    vector<long long> p, num, diff; vector<bool> inf;",
      "    WeightedUnionFind(long long n) : p(n,-1), num(n,1), diff(n), inf(n) {}",
      "    long long leader (long long x) {",
      "        if (p[x] == -1) return x;",
      "        long long y = p[x];",
      "        p[x] = leader(y);",
      "        diff[x] += diff[y];",
      "        return p[x];",
      "    }",
      "    bool merge (long long x, long long y, long long w=0) {   // x - y = w",
      "        leader(x); leader(y);  // path compression, -> diff will be based on root.",
      "        w = diff[y] - diff[x] - w;  // p[x]->x->y->p[y]",
      "        x = leader(x); y = leader(y);",
      "        if (x == y) {",
      "            if(w != 0) inf[x] = true;  // component x has infinite cycle",
      "            return w == 0;",
      "        }",
      "        if (size(x) > size(y)) swap(x, y), w = -w; // new parent = y",
      "        diff[x] = w;",
      "        p[x] = y;",
      "        num[y] += num[x];",
      "        if(inf[x]) inf[y] = true;",
      "        return true;",
      "        // merge関数はポテンシャルの差として引数を指定すれば良い",
      "        // yに対してxのポテンシャルはw大きい",
      "        // なお、diffは自分の親に移動した時のポテンシャル増加分を表すので",
      "        // diffが正であるとは、親よりもポテンシャルが低いという事",
      "        // （親ベースの増加分ではなく、それにマイナスをかけたもの）",
      "        // 従ってvのuに対するポテンシャルを求めたいのであれば",
      "        // diff[u]-diff[v]となる事に注意（感覚的には逆と思えてしまう）",
      "    }",
      "    bool same (long long x, long long y) { return leader(x) == leader(y); }",
      "    long long size (long long x) { return num[leader(x)]; }",
      "    bool isinf(long long x) { return inf[leader(x)]; }",
      "    long long potential_diff(long long x, long long y) { // y-x (base=x)",
      "        if(!same(x,y)) return -3e18;  // no connection",
      "        if(isinf(x)) return 3e18;  // infinite cycle",
      "        return diff[x] - diff[y];  // potential(y) - potential(x);",
      "    }",
      "};",
    ],
  },
  "Snippet(frompsni)": {
    "prefix": "frompsni",
    "body": [
      "vvp from(N);",
      "rep(i, $1) {",
      "    LONGM(a, b); LONG(c);",
      "    from[a].emplace_back(b, c);",
      "    from[b].emplace_back(a, c);",
      "}",
    ],
  },
  "Snippet(Birdge_Articulation)": {
    "prefix": "bridge_articulation",
    "body": [
      "struct Bridge {",
      "    using PII = pair<int,int>;",
      "    int n, m, idx;",
      "    vector<vector<PII>> from;",
      "    vector<int> ord, low, bridge, artcl;",
      "    Bridge(int n): n(n), m(0), idx(0), from(n), ord(n,-1), low(n) {}",
      "    void add_edge(int a, int b, int ei=-1) {",
      "        if(ei==-1) {",
      "            from[a].emplace_back(b, m); from[b].emplace_back(a, m);",
      "            ++m;",
      "        } else {",
      "            from[a].emplace_back(b, ei); from[b].emplace_back(a, ei);",
      "        }",
      "    }",
      "    void start_calc() { rep(i, n) if(ord[i]==-1) dfs(i); }",
      "    void dfs(int v, int p=-1) {",
      "        ord[v] = idx++; low[v] = ord[v];",
      "        int c = 0;",
      "        bool art = false;",
      "        for(auto [nv,ei]: from[v]) if(nv!=p) {",
      "            if(ord[nv]!=-1) {",
      "                low[v] = min(low[v], ord[nv]); continue;",
      "            }",
      "            ++c;",
      "            dfs(nv, v);",
      "            low[v] = min(low[v], low[nv]);",
      "            if(low[nv]>ord[v]) bridge.push_back(ei);",
      "            if(low[nv]>=ord[v]) art = true;",
      "        }",
      "        if(p!=-1 && art) artcl.push_back(v);",
      "        if(p==-1 && c>1) artcl.push_back(v);",
      "    }",
      "    vector<int> get_bridge() { return bridge;}",
      "    vector<int> get_articulation() { return artcl;}",
      "};",
    ],
  },
  "Snippet(Cumulated Sum)": {
    "prefix": "cumsum",
    "body": [
      "template <typename T> vector<T> cumsum(vector<T> &a) {",
      "    int n = a.size();",
      "    vector<T> ret(n+1);",
      "    for(int i=0; i<n; ++i) ret[i+1] = ret[i] + a[i];",
      "    return ret;",
      "}",
      "template <typename T> vector<T> cummul(vector<T> &a) {",
      "    int n = a.size();",
      "    vector<T> ret(n+1, T(1));",
      "    for(int i=0; i<n; ++i) ret[i+1] = ret[i] * a[i];",
      "    return ret;",
      "}",
      "template <typename T> vector<vector<T>> cumsum(vector<vector<T>> &a) {",
      "    int h = a.size(), w = a[0].size();",
      "    vector<vector<T>> ret(h+1, vector<T>(w+1));",
      "    for(int i=0; i<h; ++i) for(int j=0; j<w; ++j) ret[i+1][j+1] = a[i][j];",
      "    for(int i=0; i<h; ++i) for(int j=0; j<w+1; ++j) ret[i+1][j] += ret[i][j];",
      "    for(int i=0; i<h+1; ++i) for(int j=0; j<w; ++j) ret[i][j+1] += ret[i][j];",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(Trie)": {
    "prefix": "trie",
    "body": [
      "struct Trie {",
      "    struct Node {",
      "        using MP = map<char,int>;",
      "        MP to;",
      "        int num;  // # of words that go through this node",
      "        int words; // # of words that end at this node",
      "        Node(MP to=MP(), int num=0, int words=0): to(to),num(num),words(words) {}",
      "    };",
      "    int n;  // # of nodes",
      "    vector<Node> node;",
      "    Trie(): n(1),node(1) {}  // only root node",
      "    void add(string &s) {",
      "        int v = 0;",
      "        node[0].num++;",
      "        for(auto c: s) {",
      "            if(!node[v].to.count(c)) {",
      "                node.push_back(Node());",
      "                node[v].to[c] = n;",
      "                ++n;",
      "            }",
      "            v = node[v].to[c];",
      "            node[v].num++;",
      "        }",
      "        node[v].words++;",
      "    }",
      "    int search_num(string &s) { // # of s added to the trie",
      "        int v = 0;",
      "        for(auto c: s) {",
      "            if(!node[v].to.count(c)) return 0;",
      "            v = node[v].to[c];",
      "        }",
      "        return node[v].words;",
      "    }",
      "    int search_prefix_num(string &s) { // # of words that have s as prefix",
      "        int v = 0;",
      "        int ret = node[v].num;",
      "        for(auto c: s) {",
      "            if(!node[v].to.count(c)) return 0;",
      "            v = node[v].to[c];",
      "            ret = node[v].num;",
      "        }",
      "        return ret;",
      "    }",
      "    int get_lcp(string &s) { // Use this function after s is added.",
      "        int v = 0;",
      "        int ret = 0;",
      "        for(auto c: s) {",
      "            if(!node[v].to.count(c)) return 0;",
      "            int nv = node[v].to[c];",
      "            if(node[nv].num<=1) break;",
      "            ++ret;",
      "            v = nv;",
      "        }",
      "        return ret;",
      "    }",
      "};",
    ],
  },
  "Snippet(Sieve)": {
    "prefix": "sieve",
    "body": [
      "class Sieve {",
      "    long long n;",
      "    vector<long long> sieve;",
      "    vector<int> mobius;",
      "public:",
      "    Sieve (long long n): n(n), sieve(n+1), mobius(n+1,1) {",
      "        for (long long i=2; i<=n; ++i) {",
      "            if (sieve[i] != 0) continue;",
      "            sieve[i] = i;",
      "            mobius[i] = -1;",
      "            for (long long k=2*i; k<=n; k+=i) {",
      "                if (sieve[k] == 0) sieve[k] = i;",
      "                if ((k/i)%i==0) mobius[k] = 0;",
      "                else mobius[k] *= -1;",
      "            }",
      "        }",
      "    }",
      "    bool is_prime(long long k) {",
      "        if (k <= 1 || k > n) return false;",
      "        if (sieve[k] == k) return true;",
      "        return false;",
      "    }",
      "    vector<pair<long long,long long>> factorize(long long k) {",
      "        vector<pair<long long,long long>> ret;",
      "        if (k <= 1 || k > n) return ret;",
      "        ret.emplace_back(sieve[k], 0);",
      "        while (k != 1) {",
      "            if (ret.back().first == sieve[k]) ++ret.back().second;",
      "            else ret.emplace_back(sieve[k], 1);",
      "            k /= sieve[k];",
      "        }",
      "        return ret;",
      "    }",
      "    int mu(long long k) { return mobius[k]; }",
      "};",
      "",
    ],
  },
  "Snippet(nCr for small r)": {
    "prefix": "ncr",
    "body": [
      "// Combination for very small r",
      "long long nCr (long long n, long long r) {",
      "    long long ninf = 9e18;",
      "    if(n<0 || r>n || r<0) return 0;",
      "    r = min(r, n-r);",
      "    long long ret = 1;",
      "    for(long long k=1; k<=r; ++k) {",
      "        if(n-k+1 > ninf/ret) {",
      "            assert(0&&\"[Error:nCr] Too large return value.\");",
      "        }",
      "        ret *= n-k+1;",
      "        ret /= k;",
      "    }",
      "    return ret;",
      "}",
      "long long nHr (long long n, long long r, bool one=false) {",
      "    if(!one) return nCr(n+r-1, r);",
      "    else return nCr(r-1, n-1);",
      "}",
    ],
  },
  "Snippet(Fraction)": {
    "prefix": "fraction",
    "body": [
      "//! BE CAREFUL ABOUT OVERFLOWING!",
      "//! repeated usage of +-*/ leads to overflowing",
      "//! Do not repeat +-*/ more than one time (suppose p,q<=|1e9|)",
      "//! BE CAREFUL ABOUT CALCULATION COST!",
      "//! O(logM) just for initializing",
      "struct Frac {",
      "    long long p, q;  // p/q: p over q (like y/x: y over x)",
      "    Frac(long long a=0, long long b=1) {",
      "        if (b==0) {",
      "            p = 1; q = 0;  // inf (no definition of -inf)",
      "            return;",
      "        }",
      "        long long g = gcd(a, b);",
      "        p = a/g; q = b/g;",
      "        if (q<0) {p=-p; q=-q;}",
      "    }",
      "    Frac operator+(const ll x) {",
      "        if (q==0) return Frac(1, 0);",
      "        return *this + Frac(x);",
      "    }",
      "    Frac operator+(const Frac &rhs) {",
      "        if (q==0 || rhs.q==0) return Frac(1, 0);",
      "        return Frac(p*rhs.q + q*rhs.p, q*rhs.q);",
      "    }",
      "    Frac operator-(const ll x) {",
      "        if (q==0) return Frac(1, 0);",
      "        return *this - Frac(x);",
      "    }",
      "    Frac operator-(const Frac &rhs) {",
      "        if (q==0 || rhs.q==0) return Frac(1, 0);",
      "        return Frac(p*rhs.q - q*rhs.p, q*rhs.q);",
      "    }",
      "    Frac operator*(const ll x) {",
      "        if (q==0) return Frac(1, 0);",
      "        return Frac(p*x, q);",
      "    }",
      "    Frac operator*(const Frac &rhs) {",
      "        if (q==0 || rhs.q==0) return Frac(1, 0);",
      "        return Frac(p*rhs.p, q*rhs.q);",
      "    }",
      "    Frac operator/(const ll x) {",
      "        if (q==0 || x==0) return Frac(1, 0);",
      "        return Frac(p, q*x);",
      "    }",
      "    Frac operator/(const Frac &rhs) {",
      "        if (q==0 || rhs.p==0) return Frac(1, 0);",
      "        return Frac(p*rhs.q, q*rhs.p);",
      "    }",
      "    bool operator<(const ll x) const { return *this < Frac(x); }",
      "    bool operator<(const Frac &rhs) const { return p*rhs.q - q*rhs.p < 0; }",
      "    bool operator<=(const ll x) const { return *this <= Frac(x); }",
      "    bool operator<=(const Frac &rhs) const { return p*rhs.q - q*rhs.p <= 0; }",
      "    bool operator>(const ll x) const { return *this > Frac(x); }",
      "    bool operator>(const Frac &rhs) const { return p*rhs.q - q*rhs.p > 0; }",
      "    bool operator>=(const ll x) const { return *this >= Frac(x); }",
      "    bool operator>=(const Frac &rhs) const { return p*rhs.q - q*rhs.p >= 0; }",
      "    bool operator==(const ll x) const { return (q==1 && p==x); }",
      "    bool operator==(const Frac &rhs) { return (p==rhs.p && q==rhs.q); }",
      "};",
    ],
  },
  "Snippet(Matrix)": {
    "prefix": "matrix",
    "body": [
      "//! n*n matrix",
      "const int MX = 2;  // DEFINE PROPERLY!!",
      "template <typename T>",
      "class Mat {",
      "public:",
      "    int n; T a[MX][MX];",
      "    // Initialize n*n matrix as unit matrix",
      "    Mat (int n, T *src=nullptr): n(n) {  // src must be a pointer (e.g. Mat(n,*src))",
      "        if(!src) {",
      "            for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "                if(i==j) a[i][j] = 1;",
      "                else a[i][j] = 0;",
      "            }",
      "        } else {",
      "            for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "                a[i][j] = src[i*n+j];",
      "            }",
      "        }",
      "    }",
      "    // Define operator*",
      "    Mat operator* (const Mat &rhs) {  // Mat * Mat",
      "        Mat ret(n);",
      "        for (int i=0; i<n; ++i) ret.a[i][i] = 0;  // zero matrix",
      "        for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "            for (int k=0; k<n; ++k) {",
      "                ret.a[i][j] += a[i][k] * rhs.a[k][j];",
      "            }",
      "        }",
      "        return ret;",
      "    }",
      "    vector<T> operator* (const vector<T> &rhs) {  // Mat * vector",
      "        vector<T> ret(n, 0);",
      "        for (int j=0; j<n; ++j) for (int k=0; k<n; ++k) {",
      "            ret[j] += a[j][k] * rhs[k];",
      "        }",
      "        return ret;",
      "    }",
      "    Mat operator* (const T &x) {  // Mat * scaler",
      "        Mat ret(n);",
      "        for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "            ret.a[i][j] = a[i][j]*x;",
      "        }",
      "        return ret;",
      "    }",
      "    Mat inv() {  // only for 2*2 matrix & NOT USE IF det(Mat)==0!!!",
      "        T det = a[0][0]*a[1][1]-a[0][1]*a[1][0];",
      "        if(abs(det)<EPS) assert(0&&\"[Error]det(Mat)==0\");",
      "        Mat ret(n);",
      "        ret.a[0][0] = a[1][1], ret.a[0][1] = -a[0][1];",
      "        ret.a[1][0] = -a[1][0], ret.a[1][1] = a[0][0];",
      "        ret = ret * (1/det);",
      "        return ret;",
      "    }",
      "    void transpose() {",
      "        for(long long i=0; i<n; ++i) for(long long j=0; j<i; ++j) {",
      "            swap(a[i][j], a[j][i]);",
      "        }",
      "    }",
      "    // power k (A^k)",
      "    Mat pow(long long k) {",
      "        return pow_recursive(*this, k);",
      "    }",
      "    Mat pow_recursive(Mat b, long long k) {",
      "        Mat ret(b.n);",
      "        if (k == 0) return ret;",
      "        if (k%2 == 1) ret = b;",
      "        Mat tmp = pow_recursive(b, k/2);",
      "        return ret * tmp * tmp;",
      "    }",
      "    T ij(long long i, long long j) {",
      "        return a[i][j];",
      "    }",
      "#ifdef __DEBUG",
      "    void print(string debugname=\"------\") {  // for debug",
      "        cerr << n << '\\\\n';",
      "        cerr << debugname << \":\\\\n\";",
      "        for (int i=0; i<n; ++i) for (int j=0; j<n; ++j) {",
      "            cerr << a[i][j].val() << (j==n-1? '\\\\n': ' ');",
      "        }",
      "        cerr << \"---------\" << '\\\\n';",
      "    }",
      "#else",
      "    void print(string debugname=\"------\") {}",
      "#endif",
      "};",
    ],
  },
  "Snippet(XorBase)": {
    "prefix": "xor_base",
    "body": [
      "//! O(ROW * COL^2 / 64?)",
      "const int COL = 300;",
      "using BS = bitset<COL>; // size=COL",
      "using vBS = vector<BS>;",
      "struct XorBase {",
      "    int ROW;",
      "    int rank = 0;",
      "    vBS base;",
      "    XorBase(int n): ROW(n), base(n) {}",
      "    void initialize(vBS _base) { base = _base;} ",
      "    void set_new_row(BS bs) { // BE CAREFUL ABOUT CALCULATION COST",
      "        if(rank==ROW) return;",
      "        base[rank] = bs;",
      "        sweep();  // O(ROW * COL^2 / 64?)",
      "    }",
      "    void sweep() {",
      "        rank = 0;",
      "        for(int j=0; j<COL; ++j) {  // find pivot for column j",
      "            int pi = -1;  // pivot i",
      "            for(int i=rank; i<ROW; ++i) {",
      "                if(!base[i][j]) continue;",
      "                pi = i; break;",
      "            }",
      "            if(pi==-1) continue;  // no pivot at column j",
      "",
      "            swap(base[rank], base[pi]);",
      "            // delete all other 1 at column j",
      "            for(int i=0; i<ROW; ++i) {",
      "                if(i==rank) continue;",
      "                if(!base[i][j]) continue;",
      "                base[i] ^= base[rank];",
      "            }",
      "            ++rank;",
      "        }",
      "    }",
      "    vBS get_base() { return base;}",
      "    int get_rank() { return rank;}",
      "    BS get_row(int i) { return base[i]; }",
      "    vector<int> find_pivots() { // ret[idx_col] = idx_row",
      "        vector<int> ret(COL, -1);",
      "        int j = 0;",
      "        for(int i=0; i<rank; ++i) {",
      "            while(j<COL && !base[i][j]) ++j;",
      "            if(j<COL) ret[j] = i;",
      "        }",
      "        return ret;",
      "    }",
      "    //! ランクやピボット位置が同じでも基底が違えば作れる行列は異なる事に注意！",
      "    //! eg) [[1,1,0],[0,0,1]] != [[1,0,0],[0,0,1]]",
      "};",
    ],
  },
  "Snippet(Vectorll)": {
    "prefix": "vectorll",
    "body": [
      "struct Vecll {",
      "    long long x, y;",
      "    Vecll(long long x=0, long long y=0): x(x), y(y) {}",
      "    Vecll& operator+=(const Vecll &o) { x += o.x; y += o.y; return *this; }",
      "    Vecll operator+(const Vecll &o) const { return Vecll(*this) += o; }",
      "    Vecll& operator-=(const Vecll &o) { x -= o.x; y -= o.y; return *this; }",
      "    Vecll operator-(const Vecll &o) const { return Vecll(*this) -= o; }",
      "    // cross>0 means *this->v is counterclockwise.",
      "    long long cross(const Vecll &o) const { return x*o.y - y*o.x; }",
      "    long long dot(const Vecll &o) const { return x*o.x + y*o.y; }",
      "    long long norm2() const { return x*x + y*y; }",
      "    double norm() const {return sqrt(norm2()); }",
      "    Vecll rot90(bool counterclockwise=true) { ",
      "        if(counterclockwise) return Vecll(-y, x);",
      "        else return Vecll(y, -x);",
      "    }",
      "    int ort() const { // orthant",
      "        if (x==0 && y==0 ) return 0;",
      "        if (y>0) return x>0 ? 1 : 2;",
      "        else return x>0 ? 4 : 3;",
      "    }",
      "    bool operator<(const Vecll& v) const {",
      "        int o = ort(), vo = v.ort();",
      "        if (o != vo) return o < vo;",
      "        return cross(v) > 0;",
      "    }",
      "};",
      "istream& operator>>(istream& is, Vecll& v) {",
      "    is >> v.x >> v.y; return is;",
      "}",
      "ostream& operator<<(ostream& os, const Vecll& v) {",
      "    os<<\"(\"<<v.x<<\",\"<<v.y<<\")\"; return os;",
      "}",
      "bool overlapping(long long l1, long long r1, long long l2, long long r2) {",
      "    if(l1>r1) swap(l1, r1);",
      "    if(l2>r2) swap(l2, r2);",
      "    long long lmax = max(l1, l2);",
      "    long long rmin = min(r1, r2);",
      "    return lmax <= rmin;",
      "}",
      "// v1-v2 cross v3-v4?",
      "// just point touch -> true",
      "bool crossing(const Vecll &v1, const Vecll &v2, const Vecll &v3, const Vecll &v4) {",
      "    long long c12_13 = (v2-v1).cross(v3-v1), c12_14 = (v2-v1).cross(v4-v1);",
      "    long long c34_31 = (v4-v3).cross(v1-v3), c34_32 = (v4-v3).cross(v2-v3);",
      "    if(c12_13 * c12_14 > 0) return false;",
      "    if(c34_31 * c34_32 > 0) return false;",
      "    if(c12_13==0 && c12_14==0) {  // 4 points on the same line",
      "        // both x & y conditions necessary considering vertical cases",
      "        if(overlapping(v1.x,v2.x,v3.x,v4.x) &&",
      "           overlapping(v1.y,v2.y,v3.y,v4.y)) return true;",
      "        else return false;",
      "    }",
      "    return true;",
      "}",
    ],
  },
  "Snippet(Complex)": {
    "prefix": "complex",
    "body": [
      "struct Complex {",
      "    long long a, b;",
      "    Complex(long long a, long long b): a(a), b(b) {}",
      "    Complex operator+(const Complex &o) const { return Complex(a+o.a, b+o.b); }",
      "    Complex& operator+=(const Complex &o) { *this = *this + o; return *this; }",
      "    Complex operator-(const Complex &o) const { return Complex(a-o.a, b-o.b); }",
      "    Complex& operator-=(const Complex &o) { *this = *this - o; return *this; }",
      "    Complex operator*(const Complex &o) const { return Complex(a*o.a-b*o.b, a*o.b+b*o.a); }",
      "    Complex& operator*=(const Complex &o) { *this = *this * o; return *this; }",
      "    bool operator<(const Complex &o) const {",
      "        if(a==o.a) return b<o.b;",
      "        return a<o.a;",
      "    }",
      "    bool operator==(const Complex &o) const { return a==o.a && b==o.b; }",
      "    long long norm2() { return a*a + b*b; }",
      "};",
    ],
  },
  "Snippet(Merge Sort Tree)": {
    "prefix": "merge_sort_tree",
    "body": [
      "struct MergeSortTree {",
      "    int n;",
      "    vector<vector<long long>> a, s; // s: cumulated sum",
      "    MergeSortTree(int mx) {",
      "        n = 1;",
      "        while(n<mx) n<<=1;",
      "        a.resize(n*2);",
      "        s.resize(n*2, vl(1));",
      "    }",
      "    void set_only(int i, long long x) { // build() is needed afterwards",
      "        assert(i>=0 && i<n);",
      "        i += n;",
      "        a[i] = {x};",
      "        s[i] = {0, x};",
      "    }",
      "    void set(int i, long long x) { // [CAUTION] O(N*log(N)) for 1 execution",
      "        assert(i>=0 && i<n);",
      "        set_only(i, x);",
      "        i += n; i>>=1;",
      "        while(i) {",
      "            update(i);",
      "            i>>=1;",
      "        }",
      "    }",
      "    void update(int i) {",
      "        assert(i>=1 && i<2*n);",
      "        int l = i<<1, r = l|1;",
      "        a[i] = vector<long long>();",
      "        merge(a[l].begin(),a[l].end(),a[r].begin(),a[r].end(),",
      "              back_inserter(a[i]));",
      "        int m = a[i].size();",
      "        s[i].resize(m+1);",
      "        for(int j=0; j<m; ++j) s[i][j+1] = s[i][j] + a[i][j];",
      "    }",
      "    void build() {",
      "        for(int i=n-1; i>=1; --i) { update(i); }",
      "    }",
      "    long long get(int i, long long x) { // i = nodeid - n",
      "        i += n;",
      "        assert(i>=1 && i<2*n);",
      "        int idx = upper_bound(a[i].begin(), a[i].end(), x) - a[i].begin();",
      "        return s[i][idx];",
      "    }",
      "    long long prod(int ql, int qr, long long x) { // cumsum s.t. A[i]<=x",
      "        assert(ql>=0 && qr<=n);",
      "        auto f=[&](auto f, int l, int r, long long i) -> long long {",
      "            if(r<=ql || l>=qr) return 0;",
      "            if(l>=ql && r<=qr) return get(i-n, x);",
      "            int m = (l+r)/2;",
      "            long long ret = f(f, l, m, i<<1) + f(f, m, r, (i<<1)|1);",
      "            return ret;",
      "        };",
      "        long long ret = f(f, 0, n, 1);",
      "        return ret;",
      "    }",
      "};",
    ],
  },
  "Snippet(Date)": {
    "prefix": "date",
    "body": [
      "struct Date {",
      "    int y, m, d;",
      "    vector<int> mon, mon_cum;",
      "    Date(int y, int m, int d): y(y), m(m), d(d), mon(12), mon_cum(13) {",
      "        mon = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};",
      "        for(int i=0; i<12; ++i) mon_cum[i+1] = mon_cum[i] + mon[i];",
      "    }",
      "    int total_days() {",
      "        int ret = year_to_day(y-1) + mon_cum[m-1] + d;",
      "        if(is_leap(y) && m>=3) ++ret;",
      "        ret += 6;  // fine adjustment so that Monday = 0",
      "        return ret;",
      "    }",
      "    int weekday() {  // 0:Monday - 6:Sunday",
      "        int ret = total_days() % 7;",
      "        return ret;",
      "    }",
      "    int year_to_day(int y) {",
      "        int ret = y*365; ret += y/4; ret -= y/100; ret += y/400;",
      "        return ret;",
      "    }",
      "    bool is_leap(int y) {",
      "        if(y%400==0) return true;",
      "        if(y%4==0 && y%100!=0) return true;",
      "        return false;",
      "    }",
      "    tuple<int,int,int> get_day() {",
      "        return {y,m,d};",
      "    }",
      "    void inc_day() { // +1day",
      "        if(m==12 && d==31) { ++y, m=1, d=1; return; }",
      "        int lim = mon[m-1];",
      "        if(is_leap(y) && m==2) ++lim;",
      "        if(d==lim) {++m, d=1; return;}",
      "        ++d;",
      "    };",
      "};",
    ],
  },
  "Snippet(is_prime)": {
    "prefix": "is_prime",
    "body": [
      "bool is_prime(long long n) {",
      "    if(n<=1) return false;",
      "    for(long long i=2; i*i<=n; ++i) {",
      "        if(n%i==0) return false;",
      "    }",
      "    return true;",
      "}",
      "",
    ],
  },
  "Snippet(count)": {
    "prefix": "count",
    "body": [
      "//! count the # of t in s.  O(|S||T|)",
      "long long count(string &s, string t) {",
      "    long long ret = 0;",
      "    long long i=0;",
      "    while(i<(long long)s.size()) {",
      "        if(s.substr(i,t.size()) == t) ++ret, i+=t.size();",
      "        else ++i;",
      "    }",
      "    return ret;",
      "}",
      "long long count(vector<string> &s, string t) {",
      "    long long ret = 0;",
      "    for(long long i=0; i<(long long)s.size(); ++i) {",
      "        ret += count(s[i], t);",
      "    }",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(subsequence)": {
    "prefix": "subsequence",
    "body": [
      "//! Judge if t is subsequence of s.",
      "//! If ret==t.size(), then t is subsequence of s.",
      "long long subsequence(string &s, string &t) {",
      "    long long sn = s.size(), tn = t.size();",
      "    long long ti = 0;",
      "    for(long long si=0; si<sn && ti<tn; ++si) {",
      "        if(s[si]==t[ti]) ++ti;",
      "    }",
      "    return ti;",
      "}",
    ],
  },
  "Snippet(instring)": {
    "prefix": "instr_getline",
    "body": [
      "string instr() {",
      "    string ret;",
      "    getline(cin, ret);",
      "    if(ret.back()<=31 || ret.back()>=127) ret.pop_back();",
      "    return ret;",
      "}",
    ],
  },
  "Snippet(RangeBIT)": {
    "prefix": "range_bit(fenwick_tree)",
    "body": [
      "template<typename T>",
      "struct RangeBIT {",
      "    long long size;",
      "    vector<vector<T>> bit;",
      "    RangeBIT (int _n): size(_n+1), bit(2, vector<T>(_n+1)) {}",
      "    void add(int l, int r, T x) {  // [l,r) half-open interval",
      "        add_sub(0, l, -x*(l-1)); add_sub(0, r, x*(r-1));",
      "        add_sub(1, l, x); add_sub(1, r, -x);",
      "    }",
      "    T sum(int l, int r) { // [l,r) half-open interval",
      "        return sum0(r-1) - sum0(l-1);",
      "    }",
      "    T sum0(int i) {  // [0,i] closed interval",
      "        return sum_sub(0,i) + sum_sub(1,i)*i;",
      "    }",
      "    void add_sub(int p, int i, T x) {",
      "        ++i;  // 0-index -> 1_index",
      "        assert(i>=1 && i<=size); // i<=size is not necessarily needed (ignored afterwards anyway)",
      "        for(; i<size; i+=i&-i) bit[p][i] += x;",
      "    }",
      "    T sum_sub(int p, int i) {  // [0,i] closed interval",
      "        ++i;  // 0-index -> 1_index",
      "        assert(i>=0 && i<size); // i==0 -> return 0",
      "        T ret(0);",
      "        for(; i>0; i-=i&-i) ret += bit[p][i];",
      "        return ret;",
      "    }",
      "};",
    ],
  },
  "Snippet(ImplicitTreap)": {
    "prefix": "implicit_treap",
    "body": [
      "template<class T,T(*op)(T,T),T(*e)(),class F,T(*mapping)(F f,T x),F(*composition)(F f,F g),F(*id)()>",
      "class ImplicitTreap{",
      "    struct Node{",
      "        T val,acc=e();",
      "        int priority;",
      "        int cnt=1;",
      "        F lazy=id();",
      "        bool rev=false;",
      "        Node *l, *r;",
      "        Node(T val,int priority):val(val),priority(priority),l(nullptr),r(nullptr){};",
      "    }",
      "    *root=nullptr;",
      "    using Tree=Node *;",
      "",
      "    int cnt(Tree t) { return t ? t->cnt : 0; }",
      "    T acc(Tree t){ return t ? t->acc : e(); }",
      "    void update(Tree t){",
      "        if(t){",
      "            t->cnt=1+cnt(t->l)+cnt(t->r);",
      "            t->acc=op(t->val,op(acc(t->l),acc(t->r)));",
      "        }",
      "    }",
      "    void pushdown(Tree t){",
      "        if(t && t->rev){",
      "            t->rev=false;",
      "            std::swap(t->l,t->r);",
      "            if(t->l)t->l->rev^=1;",
      "            if(t->r)t->r->rev^=1;",
      "        }",
      "        if(t && t->lazy!=id()){",
      "            if(t->l){",
      "                t->l->lazy=composition(t->l->lazy,t->lazy);",
      "                t->l->acc=mapping(t->lazy,t->l->acc);",
      "            }",
      "            if(t->r){",
      "                t->r->lazy=composition(t->r->lazy,t->lazy);",
      "                t->r->acc=mapping(t->lazy,t->r->acc);",
      "            }",
      "            t->val=mapping(t->lazy,t->val);",
      "            t->lazy=id();",
      "        }",
      "        update(t);",
      "    }",
      "    void split(Tree t, int key, Tree& l,Tree& r){",
      "        if(!t){",
      "            l=r=nullptr;",
      "            return;",
      "        }",
      "        pushdown(t);",
      "        int implicit_key=cnt(t->l)+1;",
      "        if(key<implicit_key){",
      "            split(t->l,key,l,t->l),r=t;",
      "        }else{",
      "            split(t->r,key-implicit_key,t->r,r),l=t;",
      "        }",
      "        update(t);",
      "    }",
      "    void insert(Tree& t,int key,Tree item){",
      "        Tree t1,t2;",
      "        split(t,key,t1,t2);",
      "        merge(t1,t1,item);",
      "        merge(t,t1,t2);",
      "    }",
      "    void merge(Tree& t, Tree l, Tree r){",
      "        pushdown(l);",
      "        pushdown(r);",
      "        if(!l || !r){",
      "            t=l?l:r;",
      "        }else if(l->priority>r->priority){",
      "            merge(l->r,l->r,r),t=l;",
      "        }else{",
      "            merge(r->l,l,r->l),t=r;",
      "        }",
      "        update(t);",
      "    }",
      "    void erase(Tree& t,int key){",
      "        Tree t1,t2,t3;",
      "        split(t,key+1,t1,t2);",
      "        split(t1,key,t1,t3);",
      "        merge(t,t1,t2);",
      "    }",
      "    T prod(Tree t,int l,int r){",
      "        Tree t1,t2,t3;",
      "        split(t,l,t1,t2);",
      "        split(t2,r-l,t2,t3);",
      "        T ret=t2->acc;",
      "        merge(t2,t2,t3);",
      "        merge(t,t1,t2);",
      "        return ret;",
      "    }",
      "    void apply(Tree t,int l,int r,F x){",
      "        Tree t1,t2,t3;",
      "        split(t,l,t1,t2);",
      "        split(t2,r-l,t2,t3);",
      "        t2->lazy=composition(t2->lazy,x);",
      "        t2->acc=mapping(x,t2->acc);",
      "        merge(t2,t2,t3);",
      "        merge(t,t1,t2);",
      "    }",
      "    void reverse(Tree t,int l,int r){",
      "        if(l>r)return;",
      "        Tree t1,t2,t3;",
      "        split(t,l,t1,t2);",
      "        split(t2,r-l,t2,t3);",
      "        t2->rev^=1;",
      "        merge(t2,t2,t3);",
      "        merge(t,t1,t2);",
      "    }",
      "    void rotate(Tree t,int l,int m,int r){",
      "        reverse(t,l,r);",
      "        reverse(t,l,l+r-m);",
      "        reverse(t,l+r-m,r);",
      "    }",
      "    void dump(Tree t) {",
      "        if (!t) return;",
      "        pushdown(t);",
      "        dump(t->l);",
      "        std::cerr << t->val << \" \";",
      "        dump(t->r);",
      "    }",
      "public:",
      "    ImplicitTreap() {}",
      "    ImplicitTreap(std::vector<T> as){",
      "        std::reverse(as.begin(),as.end());",
      "        for(T a:as){ insert(0,a); }",
      "    }",
      "    void insert(int pos,T val){",
      "        //valをposの場所に追加する O(log N)",
      "        insert(root,pos,new Node(val,rand()));",
      "    }",
      "    void erase(T pos){",
      "        //posにある要素を消す O(log N)",
      "        erase(root,pos);",
      "    }",
      "    int size(){ return cnt(root); }",
      "    T operator[](int pos) {",
      "        Tree t1, t2, t3;",
      "        split(root, pos + 1, t1, t2);",
      "        split(t1, pos, t1, t3);",
      "        T ret = t3->acc;",
      "        merge(t1, t1, t3);",
      "        merge(root, t1, t2);",
      "        return ret;",
      "    }",
      "    T prod(int l, int r){",
      "        //[l,r)の区間 O(log N)",
      "        return prod(root,l,r);",
      "    }",
      "    void apply(int l,int r,F x){ apply(root,l,r,x); }",
      "    void reverse(int l,int r){ reverse(root,l,r); }",
      "    void rotate(int l,int m,int r){ rotate(root,l,m,r); }",
      "    void dump(){ ",
      "        #ifdef __DEBUG",
      "        dump(root);std::cerr<<std::endl;",
      "        #endif",
      "    }",
      "};",
    ],
  },
  "Snippet(z_algorithm)": {
    "prefix": "z_algorithm",
    "body": [
      "vector<long long> z_algo(string s) {",
      "    long long n = s.size();",
      "    vector<long long> a(n);",
      "    long long from = -1, last = -1;",
      "    for (long long i = 1; i < n; ++i) {",
      "        long long same = 0;  // length of same substring",
      "        // skip duplicated search",
      "        if (from != -1) same = min(a[i-from], max(last - i, 0LL));",
      "        // move forward while possible",
      "        while (i + same < n && s[same] == s[i+same]) ++same;",
      "        a[i] = same;",
      "        if(last < i + same) {  // update from & last",
      "            from = i;",
      "            last = i+same;",
      "        }",
      "    }",
      "    a[0] = n;  // substitute ovious value at last",
      "    return a;",
      "}",
      "vector<long long> z_algo(vector<long long> s) {",
      "    long long n = s.size();",
      "    vector<long long> a(n);",
      "    long long from = -1, last = -1;",
      "    for (long long i = 1; i < n; ++i) {",
      "        long long same = 0;  // length of same substring",
      "        // skip duplicated search",
      "        if (from != -1) same = min(a[i-from], max(last - i, 0LL));",
      "        // move forward while possible",
      "        while (i + same < n && s[same] == s[i+same]) ++same;",
      "        a[i] = same;",
      "        if(last < i + same) {  // update from & last",
      "            from = i;",
      "            last = i+same;",
      "        }",
      "    }",
      "    a[0] = n;  // substitute ovious value at last",
      "    return a;",
      "}",
    ],
  },
  "Snippet(Diameter)": {
    "prefix": "diameter",
    "body": [
      "struct Diameter {",
      "    int n, a, b; bool done=false;",
      "    long long diam;",
      "    using II = pair<int,int>;",
      "    using LI = pair<long long,int>;",
      "    vector<vector<LI>> from;",
      "    Diameter(int n): n(n), from(n) {}",
      "    void add_edge(int a, int b, long long c=1) {",
      "        assert(0<=a && a<n && 0<=b && b<n);",
      "        from[a].emplace_back(b, c);",
      "        from[b].emplace_back(a, c);",
      "    }",
      "    LI dfs(int v, long long d=0, int p=-1) {",
      "        LI ret(d, v);",
      "        for(auto [nv,c]: from[v]) if(nv!=p) {",
      "            ret = max(ret, dfs(nv, d+c, v));",
      "        }",
      "        return ret;",
      "    }",
      "    II get_end_points() {",
      "        if(done) return {a,b};",
      "        done = true;",
      "        a = dfs(0).second;",
      "        auto [dtmp, btmp] = dfs(a);",
      "        b = btmp, diam = dtmp;",
      "        return {a,b};",
      "    }",
      "    int get_diameter() {",
      "        get_end_points();",
      "        return diam;",
      "    }",
      "    // calculate dist(N) from sv using DFS",
      "    vector<long long> caldist(int sv) {",
      "        assert(0<=sv && sv<n);",
      "        vector<long long> dist(n);",
      "        auto dfs=[&](auto f, int v, long long d=0, int p=-1) -> void {",
      "            dist[v] = d;",
      "            for(auto [nv,c]: from[v]) if(nv!=p) { f(f, nv, d+c, v); }",
      "        };",
      "        dfs(dfs, sv);",
      "        return dist;",
      "    }",
      "};",
    ],
  },
  "Snippet(FenwickTree_BIT)": {
    "prefix": "fenwick_tree_bit",
    "body": [
      "template<typename T>",
      "struct BIT {",
      "    long long size;",
      "    vector<T> bit;",
      "    BIT (int _n): size(_n+1), bit(_n+1) {}",
      "    void add(int i, T x) {",
      "        ++i;  // 0-index -> 1_index",
      "        assert(i>=1 && i<size);",
      "        for(; i<size; i+=i&-i) bit[i] += x;",
      "    }",
      "    T sum(int l, int r) {  // [l,r) half-open interval",
      "        return sum0(r-1) - sum0(l-1);",
      "    }",
      "    T sum0(int i) {  // [0,i] closed interval",
      "        ++i;  // 0-index -> 1_index",
      "        assert(i>=0 && i<size); // i==0 -> return 0",
      "        T ret(0);",
      "        for(; i>0; i-=i&-i) ret += bit[i];",
      "        return ret;",
      "    }",
      "    int lower_bound(T x) {",
      "        int t=0, w=1;",
      "        while(w<size) w<<=1;",
      "        for(; w>0; w>>=1) {",
      "            if(t+w<size && bit[t+w]<x) { x -= bit[t+w]; t += w; }",
      "        }",
      "        return t;",
      "    }",
      "    void dump() {",
      "        #ifdef __DEBUG",
      "        for(int i=0; i<size-1; ++i) { cerr<<sum(i,i+1)<<' '; } cerr<<'\\\\n';",
      "        #endif",
      "    }",
      "};",
    ],
  },
  "Snippet(SegTree)": {
    "prefix": "segtree",
    "body": [
      "template <class S, S(*op)(S, S), S(*e)()>",
      "struct SegTree {",
      "    int n, mx;",
      "    vector<S> a;",
      "    SegTree(int mx): mx(mx) {",
      "        n = 1;",
      "        while(n<mx) n<<=1;",
      "        a.resize(n*2, e());",
      "    }",
      "    void set_only(int i, S x, bool do_op=true) { // build() is needed afterwards",
      "        assert(i>=0 && i<n);",
      "        i += n;  // i is node id",
      "        if(do_op) a[i] = op(a[i], x);",
      "        else a[i] = x;",
      "    }",
      "    void set(int i, S x, bool do_op=true) {",
      "        assert(i>=0 && i<n);",
      "        set_only(i, x, do_op);",
      "        i += n; i>>=1;  // i is node id",
      "        while(i) {",
      "            update(i);",
      "            i>>=1;",
      "        }",
      "    }",
      "    void update(int i) {  // i is node id",
      "        assert(i>=1 && i<2*n);",
      "        int l = i<<1, r = l|1;  // l,r are children",
      "        a[i] = op(a[l], a[r]);",
      "    }",
      "    void build() {",
      "        for(int i=n-1; i>=1; --i) { update(i); }",
      "    }",
      "    S get(int i) { // i = nodeid - n",
      "        i += n;",
      "        assert(i>=1 && i<2*n);",
      "        return a[i];",
      "    }",
      "    S prod(int ql, int qr) {",
      "        assert(ql>=0 && qr<=n);",
      "        auto f=[&](auto f, int l, int r, int i) -> S {",
      "            if(r<=ql || l>=qr) return e();",
      "            if(l>=ql && r<=qr) return get(i-n);",
      "            int m = (l+r)/2;",
      "            S ret = op(f(f, l, m, i<<1), f(f, m, r, (i<<1)|1));",
      "            return ret;",
      "        };",
      "        S ret = f(f, 0, n, 1);",
      "        return ret;",
      "    }",
      "    S all_prod() { return a[1]; }",
      "    int max_right(int l, auto f) {",
      "        assert(l>=0 && l<=mx);",
      "        if(l==mx) return mx;",
      "        l += n;  // l is node id",
      "        S cum = e();  // cumulation of fixed span",
      "        while(true) {",
      "            while(~l&1) l>>=1; // go to parent if left node",
      "            if(!f(op(cum, a[l]))) {  // search descendants",
      "                while(l<n) {  // while l is not leaf",
      "                    l<<=1;",
      "                    if(f(op(cum, a[l]))) {",
      "                        cum = op(cum, a[l]);",
      "                        ++l;",
      "                    }",
      "                }",
      "                return l-n;",
      "            }",
      "            cum = op(cum, a[l]); ++l;",
      "            if((l&-l)==l) break;  // right most node -> return n",
      "        }",
      "        return mx;",
      "    }",
      "    int min_left(int r, auto f) {",
      "        assert(r>=0 && r<=mx);",
      "        if(r==0) return 0;",
      "        r += n;  // r is node id(+1)",
      "        S cum = e();  // cumulation of fixed span",
      "        while(true) {",
      "            --r; // r is node id",
      "            while(r>1 && r&1) r>>=1; // go to parent if right node",
      "            if(!f(op(a[r], cum))) {  // search descendants",
      "                while(r<n) {  // while r is not leaf",
      "                    r = r<<1|1;",
      "                    if(f(op(a[r], cum))) {",
      "                        cum = op(a[r], cum);",
      "                        --r;",
      "                    }",
      "                }",
      "                return r+1-n;",
      "            }",
      "            cum = op(a[r], cum);",
      "            if((r&-r)==r) break;  // left most node -> return 0",
      "        }",
      "        return 0;",
      "    }",
      "    void dump() {",
      "        #ifdef __DEBUG",
      "        for(int i=0; i<mx; ++i) { cerr<<a[i+n]<<' '; }",
      "        cerr<<endl;",
      "        #endif",
      "    }",
      "};",
    ],
  },
}