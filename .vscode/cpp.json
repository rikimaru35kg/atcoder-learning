{
	"Snippet(Combination)": {
		"prefix": "comb",
		"body": [
			"//! Only when <= 1e6",
			"//! If not, use Combination2 class below.",
			"class Combination {",
			"    long long mx, mod;",
			"    vector<long long> facts, ifacts;",
			"public:",
			"    // argument mod must be a prime number!!",
			"    Combination(long long mx, long long mod): mx(mx), mod(mod), facts(mx+1), ifacts(mx+1) {",
			"        facts[0] = 1;",
			"        for (long long i=1; i<=mx; ++i) facts[i] = facts[i-1] * i % mod;",
			"        ifacts[mx] = modpow(facts[mx], mod-2);",
			"        for (long long i=mx-1; i>=0; --i) ifacts[i] = ifacts[i+1] * (i+1) % mod;",
			"    }",
			"    long long operator()(long long n, long long r) {",
			"        if (r < 0 || r > n || n < 0 || n > mx) return 0;",
			"        return facts[n] * ifacts[r] % mod * ifacts[n-r] % mod;",
			"    }",
			"    long long nPr(long long n, long long r) {",
			"        if (r < 0 || r > n || n < 0 || n > mx) return 0;",
			"        return facts[n] * ifacts[n-r] % mod;",
			"    }",
			"    long long get_fact(long long n) {",
			"        if (n > mx) return 0;",
			"        return facts[n];",
			"    }",
			"    long long get_factinv(long long n) {",
			"        if (n > mx) return 0;",
			"        return ifacts[n];",
			"    }",
			"    long long modpow(long long a, long long b) {",
			"        if (b == 0) return 1;",
			"        a %= mod;",
			"        long long child = modpow(a, b/2);",
			"        if (b % 2 == 0) return child * child % mod;",
			"        else return a * child % mod * child % mod;",
			"    }",
			"};"
		]

	},
	"Snippet(lower bound)" : {
		"prefix": "lowbou",
		"body": [
			"// return minimum index i where a[i] >= x, and its value a[i]",
			"// vector a must be pre-sorted in ascending (normal) order!",
			"// return value of a.size() means a.back() is not over x (a.back()<x)",
			"pair<long long,long long> lowbou(vector<long long> &a, long long x) {",
			"    long long n = a.size();",
			"    long long l = -1, r = n;",
			"    while (r - l > 1) {",
			"        long long m = (l + r) / 2;",
			"        if (a[m] >= x) r = m;",
			"        else l = m;",
			"    }",
			"    if (r != n) return make_pair(r, a[r]);",
			"    else return make_pair(n, (long long)3e18);",
			"}",
			"// return minimum index i where a[i] > x, and its value a[i]",
			"// vector a must be pre-sorted in ascending (normal) order!",
			"// return value of a.size() means a.back() is not over x (a.back()<=x)",
			"pair<long long,long long> uppbou(vector<long long> &a, long long x) {",
			"    long long n = a.size();",
			"    long long l = -1, r = n;",
			"    while (r - l > 1) {",
			"        long long m = (l + r) / 2;",
			"        if (a[m] > x) r = m;",
			"        else l = m;",
			"    }",
			"    if (r != n) return make_pair(r, a[r]);",
			"    else return make_pair(n, (long long)3e18);",
			"}",

			"// return maximum index i where a[i] <= x, and its value a[i]",
			"// vector a must be pre-sorted in ascending (normal) order!",
			"// return value of -1 means a[0] is already over x (a[0]>x)",
			"pair<long long,long long> lowbou_r(vector<long long> &a, long long x) {",
			"    long long l = -1, r = a.size();",
			"    while (r - l > 1) {",
			"        long long m = (l + r) / 2;",
			"        if (a[m] <= x) l = m;",
			"        else r = m;",
			"    }",
			"    if (l != -1) return make_pair(l, a[l]);",
			"    else return make_pair(-1, (long long)-3e18);",
			"}",

			"// return maximum index i where a[i] < x, and its value a[i]",
			"// vector a must be pre-sorted in ascending (normal) order!",
			"// return value of -1 means a[0] is already over x (a[0]>=x)",
			"pair<long long,long long> uppbou_r(vector<long long> &a, long long x) {",
			"    long long l = -1, r = a.size();",
			"    while (r - l > 1) {",
			"        long long m = (l + r) / 2;",
			"        if (a[m] < x) l = m;",
			"        else r = m;",
			"    }",
			"    if (l != -1) return make_pair(l, a[l]);",
			"    else return make_pair(-1, (long long)-3e18);",
			"}"
		]
	}
}