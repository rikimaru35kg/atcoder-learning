# はじめに
このページでは、競プロでこれまでに学んだ内容（教訓）を端的に箇条書きします。

# グラフ

## BFSとDFS
- BFSはqueue、DFSはstackで実装
- ループの先頭でpopして、空になるまで継続

# 木の直径
- 要素数が辺の数＋1のとき木になる
- xの最遠点yの最遠点zとすると、yとzの距離が直径となる

# 動的計画法

## 文字列問題
- 各文字を縦に並べ、正解文字を横に並べたdpテーブルを作ればよい
- dpテーブルと文字列の要素番号が一致するように、文字列にはあらかじめ空文字を先頭に追加しておくと良い


# Union-Find tree
- parentsの初期化、find関数（再帰関数、親更新）、unite関数
- unite関数で同じ連結木にある元同士をつながないように注意！

# ユークリッドの互除法
- gcd(a, b) = gcd(b, r) = ... = gcd(b', 0) = b'という古典的アルゴリズム
- 再帰関数で簡潔に書ける
- 拡張ユークリッドの互除法も再帰関数で簡潔に書ける（ax+by=gcd(a,b)のx, y, gcd(a,b)を求める問題）

# その他
- lower_bound関数で、配列中のどこの間に入るかわかる（戻り値がイテレータである事に注意）
- 2次元配列をIDに変える場合は x * W + yでhash化すれば良い。ただし、Wはyの範囲であることに注意！
- 問題文にある制約は使うべし（e.g. 一般解を求めると計算量が不足するが、合計枚数9999枚で支払えるとある場合には、その制約内でループを回す事で計算量を制限する事が可能）
- 小数点を出力する際はcout << fixed << setprecision(10) << x << endl;などとしないと小数点以下の桁が6桁ぐらいまでしか出力されない
